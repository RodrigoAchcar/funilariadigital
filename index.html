<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes, minimum-scale=1.0, maximum-scale=5.0">		
	<title>Funilaria Digital</title>
	<meta name="author" content="funilariadigital">
	<link rel="apple-touch-icon" sizes="180x180" href="./media/icon/favicon/apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="./media/icon/favicon/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="./media/icon/favicon/favicon-16x16.png">
	<link rel="manifest" href="./media/icon/favicon/site.webmanifest">
</head>
<body>
<canvas></canvas>
<div id="container" class="invisible">
	<div id="3d" class="contentBlock">
		<div class="topicBlock">
			<div data-width="100" data-order="0" data-type="media">
				<a href="https://funilariadigital.com.br/art-gallery-display/" target="_blank" >
					<noscript>
					<video width="462" height="260" title="Art Gallery Display" muted loop>
						<source src="./media/3d/vid/mobile/Art-Gallery-Display.mp4" type="video/mp4">
					</video>
					</noscript>
				</a>
				<a href="https://funilariadigital.com.br/open-map-scenario/" target="_blank" >
					<noscript>
					<video width="462" height="260" title="3D open map scenario" muted loop>
					<source src="./media/3d/vid/mobile/Open-Map-Scenario.mp4" type="video/mp4">
					</video>
					</noscript>
				</a>
			</div>
		</div>
		<div class="topicBlock">
			<div data-width="100" data-order="0" data-type="text">
				<h2>ART or CAD projects interactive integration</h2>
				<p>Production pipeline alignment, mesh refactor to adapt on Webgl apps. Transpile tasks from heavy rendered project to a real time, all around available platforms. Methods and fallbacks improvements for a robust build.</p>
			</div>
		</div>
		<div class="topicBlock">
			<div data-width="60 "data-order="0" data-type="text">
				<h2>Clients and workforce app features</h2>
				<p>3D as an outbound and inbound marketing resource. Appliances to enhance daily tasks. Sales presentation, point-of-sale display, team briefing display. Easy to use resources at hand available on any device.</p>
			</div>
			<div data-width="38" data-order="1" data-type="media">
			<a href="https://funilariadigital.com.br/object-3d-menu/" target="_blank" >
				<noscript>
				<img src="./media/3d/picture/mobile/3d-shape-mesh-menu.webp" alt="3d-shape-mesh-menu" />
				</noscript>
			</a>
			<noscript>
			<img src="./media/3d/picture/mobile/cad-blueprint-projection.webp" alt="cad-blueprint-projection" />
			</noscript>
			</div>
		</div>
		<div class="topicBlock">
			<div data-width="38" data-order="0" data-type="text">
				<h2>Strictly graphical layer, isolated from sensitive data</h2>
				<p>Online or offline development, usage registering for further sync. All done with regular HTML/XML inputs. Data update, increment and improve with a preserved preview integrity.</p>
			</div>
			<div data-width="60" data-order="1" data-type="text">
				<h2>Adapt, organize, improve in a blink of a refresh rate</h2>
				<p>99% devices support performance to run 3D applications. Realism, refractions, bones, particles, physics. 3D at an even higher frequency for market strategies or business tools as for entertainment. A medium to provide consumers paticipate on what they are interested.</p>
			</div>
		</div>
		<div class="topicBlock">
			<div data-width="100" data-order="0" data-type="media">
				<noscript>
				<img src="./media/3d/picture/mobile/solar-system-model-3d.webp" alt="solar-system-model-3d" />
				</noscript>
				<noscript>
				<img src="./media/3d/picture/mobile/rigging-setup-character.webp" alt="rigging-setup-character" />
				</noscript>
			</div>
		</div>
	</div>
	<div id="ux" class="contentBlock">
		<div class="topicBlock">
			<div data-width="100" data-order="0" data-type="text">
				<h2>Interfaces looking good on any screen</h2>
				<p>Services or products adaptable in any resolution. Fast layout adjust, dynamic information formatted on the fly. Render the exact media measure for each user. Ideal for humans and robots experince.</p>
			</div>
		</div>
		<div class="topicBlock">
			<div data-width="50" data-order="1" data-type="text">
				<h2>Customized templates for each demmand</h2>
				<p>User access improve convenient for what matters. Unique shapes and widgets made for every job. Your audience will be presented with original medias.</p>
			</div>
			<div data-width="34" data-order="0" data-type="media">
				<noscript>
				<img src="./media/ux/picture/mobile/custom-professional-ux.webp" alt="custom-professional-ux" />
				</noscript>
				<noscript>
				<img src="./media/ux/picture/mobile/photo-overlay-ux.webp" alt="photo-overlay-ux" />
				</noscript>
			</div>
		</div>
		<div class="topicBlock">
			<div data-width="50" data-order="0" data-type="text">
				<h2>Less third party, more logic and control</h2>
				<p>Features implemented on strict native script, only vanilla css and js. Less libraries overhead or multi featured addons. Know whats happening in all lines.</p>
			</div>
			<div data-width="48" data-order="1" data-type="text">
				<h2>Responsive layouts made clean and useful</h2>
				<p>Improve feedback insights by an easy to see interface. Notice which strategies are doing positive results and what needs to be updated.</p>
			</div>
		</div>
		<div class="topicBlock">
			<div data-width="100" data-order="0" data-type="media">
				<noscript>
				<img src="./media/ux/vector/javascript-logo.svg" alt="javascript-logo" />
				</noscript>
				<noscript>
				<img src="./media/ux/vector/webgl-logo.svg" alt="webgl-logo" />
				</noscript>
				<noscript>
				<img src="./media/ux/vector/python-logo.svg" alt="python-logo" />
				</noscript>
				<noscript>
				<img src="./media/ux/vector/css3-logo.svg" alt="css3-logo" />
				</noscript>
			</div>
		</div>
	</div>
	<div id="img" class="contentBlock">
		<div class="topicBlock">
			<div data-width="100" data-order="0" data-type="media">
				<noscript>
				<video width="462" height="260" title="Sun Timelapse" muted loop>
					<source src="./media/img/vid/mobile/sun-timelapse.mp4" type="video/mp4">
				</video>
				</noscript>
				<noscript>
				<video width="462" height="260" title="Drone Aerial Take" muted loop>
					<source src="./media/img/vid/mobile/drone-aerial.mp4" type="video/mp4">
				</video>
				</noscript>
			</div>
		</div>
		<div class="topicBlock">
			<div data-width="100" data-order="0" data-type="text">
				<h2>Artwork render for the exact pattern required</h2>
				<p>Quality files processing, fast loading time. Color fidelity, smooth organic shapes preserved. Correct frame rate for fluid animations.</p>
			</div>
		</div>
		<div class="topicBlock">
			<div data-width="64" data-order="0" data-type="text">
				<h2>Wider audience range achieved through performance</h2>
				<p>Up to date format standards to display art and documents on the right medium. Correct responses means less bounces, positive user experience</p>
			</div>
			<div data-width="32" data-order="1" data-type="media">
				<noscript>
				<img src="./media/img/picture/mobile/night-sky.webp" alt="night-sky" />
				</noscript>
			</div>
		</div>
		<div class="topicBlock">
			<div data-width="64" data-order="1" data-type="text">
				<h2>Versatile media versioning, index and access routines</h2>
				<p>Batch processing master versions for any device profiles. Aspect ratio, connection bandwidth, processing capacity. Carefuly revised for publishing.</p>
			</div>
			<div data-width="32" data-order="0" data-type="media">
				<noscript>
				<img src="./media/img/picture/mobile/uv-ligh-paint-gueixa.webp" alt="uv-ligh-paint-gueixa" />
				</noscript>
			</div>
		</div>
		<div class="topicBlock">
			<div data-width="50" data-order="0" data-type="text">
				<h2>Engagement ranking by best practices</h2>
				<p>Search engines, social media alghoritms and web analitycs prevails optimized media and code transfers. A lean payload saves time and processing, agregates priority points in the position ordering ranks.</p>
			</div>
			<div data-width="32" data-order="1" data-type="media">
				<noscript>
				<img src="./media/img/picture/mobile/lord-cat-pose.webp" alt="lord-cat-pose" />
				</noscript>
				<noscript>
				<img src="./media/img/picture/mobile/dogs-ocean.webp" alt="dogs-ocean" />
				</noscript>
			</div>
		</div>
	</div>
	<div id="seo" class="contentBlock">
		<div class="topicBlock">
			<div data-width="100" data-order="0" data-type="text">
				<h2>Automate relevant insights to figure whats profitable</h2>
				<p>Crawl, scrape and parse apps to monitor business activities. Specialized tools capable to feed, manipulate, rearrange it's parameters, narrow objectives.</p>
			</div>
		</div>
		<div class="topicBlock">
			<div data-width="100" data-order="0" data-type="media">
				<noscript>
				<img src="./media/seo/vector/seo-graphic-analysis.svg" alt="seo-graphic-analysis" />
				</noscript>
			</div>
		</div>
		<div class="topicBlock">
			<div data-width="48" data-order="0" data-type="text">
				<h2>Manage data classification to aim at efficient results</h2>
				<p>Get to the bottom of the funnel by gathering organized massive profile data. Intuitive straight forward operation rules, easy to feed, clear to visualize. Evolve strategies throughout dynamic feedbacks.</p>
			</div>
			<div data-width="50" data-order="1" data-type="text">
				<h2>Wise planning on whom to reach and how to approach</h2>
				<p>Measure partnes, suppliers and concurrency. Business management, opportunity predictions, prominent market information detection. Be on the spot of whats new, what is still providing results and what should be replaced.</p>
			</div>
		</div>
		<div class="topicBlock">
			<div data-width="100" data-order="0" data-type="media">
				<noscript>
				<img src="./media/seo/vector/seo-bars-regression.svg" alt="seo-bars-regression" />
				</noscript>
			</div>
		</div>
		<div class="topicBlock">
			<div data-width="100" data-order="0" data-type="text">
				<h2>Reviews awareness to score high ratings</h2>
				<p>Audience monitoring automations that fetches schedules data, classify gathered information, measure and triggers alert on predefined patterns. Convenient registered quantity produce valuable regression predictions to keep organic search rankings on top</p>
			</div>
		</div>
	</div>
	<div id="api" class="contentBlock">
		<div class="topicBlock">
			<div data-width="100" data-order="0" data-type="text">
				<h2>Integrate existent interface applications to enhance relations for clients and team members</h2>
				<p>Sales, workflow, optimization of any kind. Routines can be automated to a new form of interaction. New skills from the same sources. New data sources from respected reputation service providers.</p>
			</div>
		</div>
		<div class="topicBlock">
			<div data-width="100" data-order="0" data-type="media">
				<noscript>
				<img src="./media/api/vector/api-integration.svg" alt="api-integration" />
				</noscript>
			</div>
		</div>
		<div class="topicBlock">
			<div data-width="50" data-order="0" data-type="text">
				<h2>Profit with addons available on tools that you already work</h2>
				<p>Most Saas providers, Google, Meta, Reuters, Catalogs of all nature, offers a complete interface usage. Onboard internal presets with tools customization possibilities accessed by latest security procedures.</p>
			</div>
			<div data-width="48" data-order="1" data-type="text">
				<h2>Advantages of cross reference data from various sources</h2>
				<p>Bundles mounted at the desired specs by multiple service providers. With buit in cross brand hooks, officialy registered. If unavailable it's implementable. Live, safe, legal.</p>
			</div>
		</div>
		<div class="topicBlock">
			<div data-width="100" data-order="0" data-type="media">
				<noscript>
				<img src="./media/api/vector/api-handshake-connection-security.svg" alt="api-handshake-connection-security" />
				</noscript>
			</div>
		</div>
		<div class="topicBlock">
			<div data-width="44" data-order="0" data-type="text">
				<h2>Social media management simplified, unified</h2>
				<p>Most technologies have their services integration features allowed to intertwine to different brands. Social medias, websites, analytics, apps, converged to one assistance asset.</p>
			</div>
			<div data-width="40" data-order="1" data-type="media">
				<noscript>
				<img src="./media/api/picture/mobile/api-google-maps-gps-track.webp" alt="api-google-maps-gps-track" />
				</noscript>
				<noscript>
				<img src="./media/api/picture/mobile/api-google-maps-data-overlay.webp" alt="api-google-maps-data-overlay" />
				</noscript>
				<noscript>
				<img src="./media/api/vector/api-multi-providers-cross-reference.svg" alt="api-multi-providers-cross-reference" />
				</noscript>
			</div>
		</div>
	</div>
	<div id="info" class="contentBlock">
		<div class="topicBlock">
			<div data-width="100" data-order="0" data-type="media">
				<noscript>
				<img src="./media/info/picture/mobile/about-rodrigo-achcar.webp" alt="about-rodrigo-achcar" />
				</noscript>
			</div>
		</div>
		<div class="topicBlock">
			<div data-width="100" data-order="0" data-type="text">
				<h2>Rodrigo Rodrigues Achcar</h2>
				<p>Specialized 3D professional (Autodesk Maya, DRC São Paulo). Inclined on mesh set up for animation, rigging. As time went by I've began to get media production and coding jobs, gov contracts freelances. Afterwards got into join service auctions disputes. Really liked contract, budget plan and price bid parts.</p>
				<p>Gov contracts gave me opportunities to travel around Brasil and work on some complex tasks. Such as the whole media production process, rendering adequate outputs, massive document and media reprocess, interactive display resources, build 2D and 3D animation styles, aerial captures, geopositioned orthomosaic maps.</p>
				<p>Around 2009 I felt the need to develop tools to read the auctions offers. Since a lot of time was required searching for bids I've begin to code automations to get the daily posts, sorted by my interest, database input and content views. Started on php, Joomla cms.</p>
				<p>After that I went after graphical ECMA scripts. Switched to python server side process, Django cms, expressions in mel script for Maya evolved to scripts for Blender. About 2018 I've figured that media production field wasn't my thing, decided to go for new professional challenges strictly in computing tasks. So I've decided to focus in graphical layer coding jobs.</p>
				<p>As digital marketing consolidated I had know how to what increased value, so I got back adding communication works to the systems helm, such as 3D interaction and media web formatting. Enjoyed much of data monitoring, lots of statistics to play. There's plenty of marketing and fullstack opportunities currently, although seems that I can segment my field on something I love and do for some time. I'm a graphical programmmer.</p>
			</div>
		</div>
		<div class="topicBlock">
			<div data-width="100" data-order="0" data-type="media">
				<a href="https://www.linkedin.com/in/rodrigo-achcar/" target="_blank" >
				<noscript>
				<img src="./media/info/vector/linkedin-rodrigo-achcar.svg" alt="linkedin-rodrigo-achcar" />
				</noscript>
				</a>
				<a href="https://github.com/RodrigoAchcar" target="_blank" >
				<noscript>
				<img src="./media/info/vector/github-funilaria-digital.svg" alt="github-funilaria-digital" />
				</noscript>
				</a>
				<a href="https://wa.me/5561992720142" >
				<noscript>
				<img src="./media/info/vector/whatsapp-phone-rodrigo-achcar.svg" alt="whatsapp-phone-rodrigo-achcar" />
				</noscript>
				</a>
				<a href="https://www.facebook.com/rodrigo.achcar.9/" target="_blank" >
				<noscript>
				<img src="./media/info/vector/facebook-rodrigo-achcar.svg" alt="facebook-rodrigo-achcar" />
				</noscript>
				</a>
				<a href="https://www.instagram.com/rodrigorachcar/" target="_blank" >
				<noscript>
				<img src="./media/info/vector/instagram-rodrigo-achcar.svg" alt="instagram-rodrigo-achcar" />
				</noscript>
				</a>
				<a href="mailto:rodrigor.achcar@gmail.com" target="_blank" >
				<noscript>
				<img src="./media/info/vector/email-contact.svg" alt="email-contact" />
				</noscript>
				</a>
			</div>
		</div>
	</div>
</div>
<script type="importmap">
	{
		"imports": {
			"three": "./static/js/webgl/build/three.module.js",
			"three/addons/": "./static/js/webgl/jsm/"
		}
	}
</script>
<script type="module">
import { Cache, WebGLRenderer, ACESFilmicToneMapping, Color, SRGBColorSpace, Vector2, Vector3, Scene, PerspectiveCamera, DirectionalLight, Group, Raycaster, LoadingManager, TextureLoader, VideoTexture, Mesh, MeshStandardMaterial, MeshBasicMaterial, MeshLambertMaterial, MeshPhongMaterial, PlaneGeometry, ShapeGeometry, EdgesGeometry, LineSegments, FrontSide} from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';	
import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
import { Font } from 'three/addons/loaders/FontLoader.js';
import { TTFLoader } from 'three/addons/loaders/TTFLoader.js';
import { SVGLoader } from 'three/addons/loaders/SVGLoader.js';
Cache.enabled = true;
const scn = new Scene();
const requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;
const cancelAnimationFrame = window.cancelAnimationFrame || window.mozCancelAnimationFrame;
function init(){
	setScene(scn);
	scn.fonts =  {
		rubick: {
			loaded: false, topics: [
				{ media: [{
					data:[
					{ src : 'static/fonts/rubik/Rubik-Regular.ttf', tag: 'ttf' },
					{ src : 'static/fonts/rubik/Rubik-Bold.ttf', tag: 'ttf' } ]}
				]}
			]
		}
	};
	scn.meshes = {
		homepage: {
			 loaded: false, topics: [
				{ media: [{
					data: [
					{ src : 'static/js/webgl/models/homepage/homepage.fbx', tag: 'fbx' } ]}
				]}
			]
		}
	};
	scn.loaderClasses = { fbx: [FBXLoader] , ttf: [TTFLoader], webp: [TextureLoader, generateImg], svg: [SVGLoader, generateSvg], mp4: [VideoTexture, generateVid] };
	scn.menuObjs = getMenuItems( "container" );
	loadFiles( [ scn.fonts.rubick, scn.meshes.homepage ] , buildScenario);
}
function loadFile(loaderClass, filePath) {
	return new Promise((resolve) => {
		const loader = loaderClass;
		loader.load(filePath, (data) => {
			resolve(data);
		});
	});
}
async function loadFiles( filesArray, endAction=null ){
	const manager = new LoadingManager();
	let filesLoadQtd = 0;
	let loadCount = 0;
	for(let i = 0; i < filesArray.length; i++){
		for(let j = 0; j < filesArray[i].topics.length; j++){
			if(filesArray[i].topics[j].media){
				for(let k = 0; k < filesArray[i].topics[j].media.length; k++){
					for(let l = 0; l < filesArray[i].topics[j].media[k].data.length; l++){
						if(filesArray[i].topics[j].media[k].data[l].tag !== 'mp4'){
							filesLoadQtd++;
						}
					}
				}
			}
		}
	}
	manager.onStart = function () {};
	manager.onProgress = function () {};
	manager.onLoad = function () {
		if(loadCount == filesLoadQtd){
			//console.log('loading complete');
			endAction();
			return;
		}
	};
	manager.onError = function () {};
	for(let i = 0; i < filesArray.length; i++){
		for(let j = 0; j < filesArray[i].topics.length; j++){
			if(filesArray[i].topics[j].media){
				for(let k = 0; k < filesArray[i].topics[j].media.length; k++){
					for(let l = 0; l < filesArray[i].topics[j].media[k].data.length; l++){
						if(filesArray[i].topics[j].media[k].data[l].tag !== 'mp4'){
							let data = await loadFile(new scn.loaderClasses[filesArray[i].topics[j].media[k].data[l].tag][0](manager), filesArray[i].topics[j].media[k].data[l].src);
							filesArray[i].topics[j].media[k].data[l].src = data;
							if( filesArray[i].topics[j].media[k].data[l].tag == "ttf" ){
								filesArray[i].topics[j].media[k].data[l].src = new Font( data );
							}
							loadCount++;
						}
					}
				}
			}
		}
		filesArray[i].loaded = true;
	}
}
function getMenuItems( containerId ){
	const obj = {};
	const content = document.getElementById(containerId);
	for(let i = 0; i < content.children.length; i++){
		let menuItem = content.children[i];
		let itemID = menuItem.getAttribute("id");
		obj[itemID] = { loaded : false, topics: []};
		for(let j = 0; j < menuItem.children.length; j++){
			let topics = menuItem.children[j];
			let topicObj = { media: [], text: [] };
			for(let k = 0; k < topics.children.length; k++){
				let block = topics.children[k];
				let blockObj = { type: block.getAttribute("data-type"), order: block.getAttribute("data-order"), width: block.getAttribute("data-width"), data: [] };
				for(let l = 0; l < block.children.length; l++){
					let elm = block.children[l];
					if( blockObj.type == 'text'){
						blockObj.data.push( { tag: elm.localName, info: elm.innerHTML.split(' ')} );
					}
					if( blockObj.type == 'media'){
						let dataObj = {};
						if(elm.localName == 'a'){
							dataObj.href = elm.getAttribute("href");
							elm = elm.children[0];
						}
						dataObj.src = elm.firstChild.textContent.match( /src="([^\"]+)/ )[1];
						dataObj.tag = dataObj.src.match( /(.+)\.(.+)$/ )[2];
						if(dataObj.tag == 'mp4'){
							const fragment = document.createRange().createContextualFragment(elm.firstChild.textContent).children[0];
							dataObj.src = fragment;
						}
						
						blockObj.data.push( dataObj );
					}
				}
				topicObj[blockObj.type].push(blockObj);
			}
			if(topicObj.media.length == 0){ delete topicObj.media;	}
			if(topicObj.text.length == 0){ delete topicObj.text; }
			obj[itemID].topics.push(topicObj);
		}
	}
	return obj;
}
function buildScenario(){
	scn.carousel = setCarousel();
	scn.infoContainer = setInfoContainer();
	for(let item of Object.values(scn.meshes.homepage.topics[0].media[0].data[0].src.children) ){
		let geo = item.geometry;
		let strokeMat = new MeshStandardMaterial( { color: new Color('#0E3F36'), fog: false, toneMapped: false, transparent: true } );
		let mesh = new Mesh(geo, strokeMat);
		geo.dispose();
		strokeMat.dispose();
		mesh.name = 'stroke';
		if(item.children.length > 0){
			let geoFill = item.children[0].geometry;
			let fillMat =  new MeshStandardMaterial( { color: new Color('#2BC7AC'), roughness: 1, metalness: 0, fog: false, toneMapped: false, transparent: true } );
			let meshFill = new Mesh(geoFill, fillMat);
			meshFill.name = 'fill';
			geoFill.dispose();
			fillMat.dispose();
			item.children[0].geometry.dispose();
			item.children[0].material.dispose();
			if(item.children[0].children.length > 0){
				let geoGlow = item.children[0].children[0].geometry;
				let glowMat = new MeshStandardMaterial( { color: new Color('#33EBCB'), roughness: 1, metalness: 0, fog: false, toneMapped: false, transparent: true } );
				let meshGlow = new Mesh(geoGlow, glowMat);
				meshGlow.name = 'glow';
				geoGlow.dispose();
				glowMat.dispose();
				meshFill.add(meshGlow);
			}
			mesh.add(meshFill);
		}
		mesh.scale.normalize();
		mesh.geometry.computeBoundingBox();
		mesh.geometry.computeBoundingSphere();
		mesh.bb = {x: Math.abs(mesh.geometry.boundingBox.min.x - mesh.geometry.boundingBox.max.x), y: Math.abs(mesh.geometry.boundingBox.min.y - mesh.geometry.boundingBox.max.y)}; 
		if(Object.keys(scn.menuObjs).includes(item.name)){
			let rayMesh = genRaycastMesh(mesh.bb.x, mesh.bb.y);
			rayMesh.bb = mesh.bb; 
			rayMesh.name = item.name;
			rayMesh.add(mesh);
			scn.carousel[item.name] = rayMesh;
			scn.carousel.add(rayMesh);
			scn.carouselRays.push(rayMesh);
			continue;
		}
		if(item.name == "close"){
			let rayMesh = genRaycastMesh(mesh.bb.x, mesh.bb.y);
			rayMesh.bb = mesh.bb;
			rayMesh.name = item.name;
			rayMesh.add(mesh);
			scn[item.name] = rayMesh;
			scn.add(rayMesh);
			continue;
		}
		if(item.name == "brand"){
			scn[item.name] = mesh;
			scn.add(mesh);
		}
	}
	scn.close.visible = false;
	onWindowResize();
	window.addEventListener( 'resize', onWindowResize );
	window.addEventListener( 'pointermove', onPointerMove );
	window.addEventListener( 'pointerdown', onPointerDown );
	scn.intersectedObjs = scn.carouselRays;
	delete scn.meshes;
	let htmlElmn = document.getElementsByClassName('invisible')[0];
	htmlElmn.style.opacity = 0;
	htmlElmn.style.display = 'none';
	animate();
}
function openInfo(){
	scn.moving = false;	
	scn.controls.maxDistance = scn.camLock.z;
	scn.controls.enableRotate = false;
	scn.controls.enableZoom = false;
	scn.camViewSize = calcViewSize(scn.cam, scn.camLock.z, 0, 0);
	updateObjsPos();
	scn.close.position.y = scn.close.lock.y;
	scn.infoContainer.infoTable.infoTableW = Math.trunc((scn.camViewSize.x * 0.8) *100)/100;
	scn.infoContainer.infoTable.position.x = -scn.infoContainer.infoTable.infoTableW/2;
	scn.infoContainer.infoTable.position.y = (scn.camViewSize.y/2 - scn.brand.lock.y/2);
	
	scn.infoContainer.infoTable.visible = true;
		
	let itemRotationPos = Math.PI*2 - scn.carousel[scn.currentIntersected.name]; 
	let itemRotationDelta = itemRotationPos;
	if(Math.abs(scn.carousel.rotation.y - itemRotationPos) >= Math.PI){
		if(scn.carousel.rotation.y >= itemRotationPos){
			itemRotationDelta += Math.PI*2;
		}else{
			scn.carousel.rotation.y += Math.PI*2;
		}
	}
	let carouselRotationDuration = Math.ceil(Math.abs(scn.carousel.rotation.y - itemRotationDelta));
	for(let i = 0; i < scn.carousel.children.length; i++){
		if(scn.carousel.children[i].name != scn.currentIntersected.name){
			scn.carousel.children[i].traverse(function(child){
				animeItem(child, 'material', ['opacity'], [0], 0.7);
			});
		}
	}
	changeColor(scn.currentIntersected.children[0], "active");
	animeItem(scn.cam, 'position', ['x', 'y', 'z'], [scn.camLock.x, scn.camLock.y, scn.camLock.z], 0.7);
	animeItem(scn.controls, 'target', ['y'], [scn.tgtLock.y], 0.7);
	animeItem(scn.carousel, 'position', ['y'], [scn.carousel.lock.y], 0.7);
	animeItem(scn.carousel, 'rotation', ['y'], [itemRotationDelta], carouselRotationDuration);
	animeItem(scn.currentIntersected, 'scale', ['x', 'y'], [scn.carousel.cScale*2.6, scn.carousel.cScale*2.6], 0.7);
	animeItem(scn.brand, 'scale', ['x', 'y'], [scn.brand.scalarV, scn.brand.scalarV], 0.7);
	animeItem(scn.brand, 'position', ['x', 'y'], [scn.brand.lock.x, scn.brand.lock.y], 0.7, 0, function() {
		animeItem(scn.infoContainer.infoTable, 'position', ['x'], [0], 0.7);
		animeItem(scn.infoContainer.infoTable, 'scale', ['x'], [scn.infoContainer.infoTable.infoTableW], 0.7, 0, function(){
			plotElements();
		});
		
	});
}
function plotElements(){
	let content = scn.menuObjs[ scn.currentIntersected.name ];
	let infoContainer = scn.infoContainer;
	let infoTable = infoContainer.infoTable;	
	let contentWidth = Math.trunc((infoTable.infoTableW * 0.9) *100)/100;
	let itemPadding = Math.trunc((contentWidth * 0.01) *100)/100;
	infoContainer.h2.fontSize = Math.trunc((contentWidth/20) * 100)/100;
	infoContainer.p.fontSize = Math.trunc((contentWidth/24) * 100)/100;
	infoContainer.contentHeight = 0;
	let topicHeight = 0;
	for( let i = 0; i < content.topics.length; i++){
		let topic = content.topics[i];
		let topicBlock = new Group();
		let blockHigher = 0;
		let colPosXOrder = [];
		//topic height calc by text blocks first if there's text block
		if( topic.text ){
			for( let j = 0; j < topic.text.length; j++){
				let block = topic.text[j];
				let colW = Math.ceil(((contentWidth*block.width)/100) * 100 )/100;
				let order = parseInt(block.order);
				let itemGroup = new Group();
				let scale;
				let blockHeight = 0;
				for( let k = 0; k < block.data.length; k++){
					let elmnt = block.data[k];
					let wordsArr = elmnt.info;
					let fontSize = infoContainer[elmnt.tag].fontSize;
					let fontFamily = infoContainer[elmnt.tag].fontFamily;
					let textBlock = alignTextBlock(wordsArr, colW, fontSize);
					let textMesh = generateText(textBlock, fontFamily, fontSize);
					textMesh.position.y = -blockHeight;
					scale = colW/textMesh.bb.w;
					blockHeight += (textMesh.bb.h * scale) + itemPadding;
					itemGroup.add(textMesh);
				}
				blockHeight += itemPadding;
				if(blockHeight > blockHigher){
					blockHigher = blockHeight;
				}
				topicBlock.add( itemGroup );
				colPosXOrder.push( [ order+1, colW, itemGroup] );
			}
		}
		if( topic.media ){
			for( let j = 0; j < topic.media.length; j++){
				let block = topic.media[j];
				let colW = Math.ceil(((contentWidth*block.width)/100) * 100 )/100;
				let order = parseInt(block.order);
				let itemGroup = new Group();
				let scale;
				let blockHeight = 0;
				//block text sorted first to reference blockHigher for block media
				itemGroup.name = "media";
				let mesh;
				let mediaWidthAll = 0;
				let mediaHeightAll = 0;
				let mediaAspectAll = 0;
				let elmnPosX = 0;
				let elmnPosY = 0;
				let blockAspect;
				for( let k = 0; k < block.data.length; k++){
					let elmnt = block.data[k];
					mesh = scn.loaderClasses[elmnt.tag][1](elmnt.src);
					if(elmnt.href != null){
						let rayMesh = genRaycastMesh(mesh.bb.w, mesh.bb.h);
						rayMesh.name = 'rayLink';
						rayMesh.url = elmnt.href;
						rayMesh.position.set(mesh.bb.w/2, -mesh.bb.h/2, 0);
						mesh.add(rayMesh);
						scn.topicRays.push(rayMesh);						
					}
					mediaWidthAll += mesh.bb.w;
					mediaHeightAll += mesh.bb.h;
					itemGroup.add(mesh);
				}
				mediaAspectAll = mediaWidthAll/mediaHeightAll;
				// if topic has no text block, calc blockHigher
				if(blockHigher == 0){
					blockHeight = (colW/mediaAspectAll);
					blockHigher = ((colW/mediaAspectAll)/block.data.length) + itemPadding;
				}else{
					blockHeight = blockHigher;
				}
				let mediaCanvasAspect = colW/blockHeight;
				for( let k = 0; k < itemGroup.children.length; k++){
					let elmnt = itemGroup.children[k];
					scale = ((blockHeight-itemPadding)/elmnt.bb.h)/itemGroup.children.length;
					//scale = (colW/elmnt.bb.w)/itemGroup.children.length;
					elmnt.scale.setScalar(scale);
					if(mediaCanvasAspect >= 1){
						elmnt.position.x = elmnPosX;
						elmnPosX += (elmnt.bb.w * scale) + itemPadding;
					}else{
						elmnt.position.y = -elmnPosY;
						elmnPosY += (elmnt.bb.h * scale) + itemPadding;
					}
				}
				topicBlock.add( itemGroup );
				colPosXOrder.push( [ order+1, colW, itemGroup] );
			}
		}
		//position x itemGroups by order and col position
		colPosXOrder.sort().unshift([0,0]);
		for( let j = 1; j < colPosXOrder.length; j++){
			colPosXOrder[j][2].position.x = colPosXOrder[j-1][1] + itemPadding;
		}
		topicBlock.position.x = -(contentWidth/2);
		topicBlock.position.y = - (topicHeight + itemPadding) ;
		topicHeight += blockHigher + itemPadding;
		infoContainer.infoBlock.add( topicBlock );
	}
	infoContainer.contentHeight = topicHeight;
	infoContainer.infoBlock.position.y = (scn.camViewSize.y/2 - scn.brand.lock.y);
	scn.cam.topLimit = 0;
	scn.cam.bottomLimit = -Math.trunc( infoContainer.contentHeight - scn.camViewSize.y/2 );
	displayInfo();
}
function displayInfo(){
	scn.close.visible = true;
	scn.topicRays.push(scn.close);
	//let animeArray = [];
	animeItem(scn.close, 'position', ['x'], [scn.close.lock.x], 0.5, 0);
	animeItem(scn.infoContainer.infoTable, 'scale', ['y'], [scn.infoContainer.contentHeight], 0.7);
	animeItem(scn.infoContainer.infoTable, 'position', ['y'], [-(scn.infoContainer.contentHeight/2 - (scn.camViewSize.y/2 - scn.brand.lock.y/2 ))], 0.7, 0, function(){
		for(let i = 0; i < scn.infoContainer.infoBlock.children.length; i++){
			for(let j = 0; j < scn.infoContainer.infoBlock.children[i].children.length; j++){
				for(let k = 0; k < scn.infoContainer.infoBlock.children[i].children[j].children.length; k++){
					scn.infoContainer.infoBlock.children[i].children[j].children[k].children.forEach((element) =>  animeItem(element, 'material', ['opacity'], [1], 0.5, i+j) ); 
				}
			
			}
		}
		scn.renderer.domElement.addEventListener( "wheel", wheelEvent, false);
		window.addEventListener( "keydown", keyDownEvent, false );
	});
	/*
	animeArray.push(
		animeItem(scn.close.position, 'x', scn.close.lock.x, 20, 0, 
		function(){
			let animeArray = [];
			animeArray.push(
				animeItem(scn.infoContainer.infoTable.scale, 'y', scn.infoContainer.contentHeight, 20, 0),
				animeItem(scn.infoContainer.infoTable.position, 'y', -(scn.infoContainer.contentHeight/2 - (scn.camViewSize.y/2 - scn.brand.lock.y/2 )), 20, 0,
				function(){
					let animeArray = [];
					for(let i = 0; i < scn.infoContainer.infoBlock.children.length; i++){
						let elmntGroup = scn.infoContainer.infoBlock.children[i].children;
						for(let j = 0; j < elmntGroup.length; j++){
							for(let k = 0; k < elmntGroup[j].children.length; k++){
								if(elmntGroup[j].children[k].children.length > 0){
									elmntGroup[j].children[k].children.forEach((element) => 
									animeArray.push(
										animeItem(element.material, 'opacity', 1, 20, i+j)
										) ); 
								}
								animeArray.push(
									animeItem(elmntGroup[j].children[k].material, 'opacity', 1, 20, i+j) ); } } }
					animeArray.forEach((element) => scn.renderGroup.push(element));
					scn.renderer.domElement.addEventListener( "wheel", wheelEvent, false);
					window.addEventListener( "keydown", keyDownEvent, false );
				} ) )
			animeArray.forEach((element) => scn.renderGroup.push(element));
		})	);
		
		*/
	//animeArray.forEach((element) => scn.renderGroup.push(element));
}
function closeInfo(){
	let infoContainer = scn.infoContainer;
	let infoTable = infoContainer.infoTable;
	scn.renderer.domElement.removeEventListener( "wheel", wheelEvent);
	window.removeEventListener( "keydown", keyDownEvent);
	scn.renderer.domElement.removeEventListener( "onTouchStart", onTouchStart);
	scn.renderer.domElement.removeEventListener( "onTouchMove", onTouchMove);
	/*
	let animeArray = [];
	for(let i = 0; i < infoContainer.infoBlock.children.length; i++){
		let elmntGroup = infoContainer.infoBlock.children[i].children;
		for(let j = 0; j < elmntGroup.length; j++){
			for(let k = 0; k < elmntGroup[j].children.length; k++){
				animeArray.push(
					animeItem(elmntGroup[j].children[k].material, 'opacity', 0, 20, 0)
				);
				//svg children
				if(elmntGroup[j].children[k].children.length > 0){
					elmntGroup[j].children[k].children.forEach((element) => 
					animeArray.push(
						animeItem(element.material, 'opacity', 0, 20, i+j)
						) ); 
				}
			} } 
	}
	*/
	animeItem(scn.close, 'position', ['x'], [scn.close.mov.x], 0.5, 0, function(){
		animeItem(infoTable, 'position', ['y'], [Math.trunc((scn.camViewSize.y/2 - scn.brand.lock.y/2)*100)/100], 0.7, 0, function(){
			animeItem(infoTable, 'scale', ['x'],  0, 0.5);
			animeItem(infoTable, 'position', ['x'], [-infoTable.infoTableW/2], 0.5, 0, function(){
				scn.close.visible = false;
				hideInfo(scn);
				infoContainer.infoBlock.clear();
				changeColor(scn.currentIntersected.children[0], "normal");
			});
		});
	
	});
	/*
	animeArray.push(
		animeItem(scn.close.position, 'x', scn.close.mov.x, 20, 0, 
			function(){
				let animeArray = [];
				animeArray.push(
					animeItem(infoTable.position, 'y', Math.trunc((scn.camViewSize.y/2 - scn.brand.lock.y/2)*100)/100, 20, 0, 
						function(){
							let animeArray = [];
							animeArray.push(
								animeItem(infoTable.scale, 'x',  0, 10, 0),
								animeItem(infoTable.position, 'x', -infoTable.infoTableW/2, 10, 0)
								 );
							animeArray.forEach((element) => scn.renderGroup.push(element));
							scn.close.visible = false;
							hideInfo(scn);
						}
					),
					animeItem(infoTable.scale, 'y', 0.5, 20, 0)
				);
				infoContainer.infoBlock.clear();
				changeColor(scn.currentIntersected.children[0], "normal", animeArray);
				animeArray.forEach((element) => scn.renderGroup.push(element));
			}
		)
	);
	animeArray.forEach((element) => scn.renderGroup.push(element));
	*/
}
function hideInfo(){
	scn.moving = true;
	updateObjsPos();
	for(let i = 0; i < scn.carousel.children.length; i++){
		if(scn.carousel.children[i].name != scn.currentIntersected.name){
			animeItem(scn.carousel.children[i], 'material', ['opacity'], [1], 0.6);
		}
		animeItem(scn.currentIntersected, 'scale', ['x', 'y'], [scn.carousel.cScale, scn.carousel.cScale], 0.6);
	}
	animeItem(scn.brand, 'scale', ['x', 'y'], [scn.brand.scalarV, scn.brand.scalarV], 0.6);
	animeItem(scn.brand, 'position', ['x', 'y'], [scn.brand.mov.x, scn.brand.mov.y], 0.6);
	animeItem(scn.carousel, 'position', ['y'], [scn.carousel.mov.y], 0.6);
	animeItem(scn.cam, 'position', ['x', 'y', 'z'], [scn.camMov.x, scn.camMov.y, scn.camMov.z], 0.6);
	animeItem(scn.controls, 'target', ['y'], [scn.tgtMov.y], 0.6, 0, function(){
		scn.controls.enableRotate = true;
		scn.controls.enableZoom = true;
		scn.controls.maxDistance = scn.camMov.z;
		scn.topicRays = [];	
	});
}

function onWindowResize() {
	scn.renderer.setSize( window.innerWidth, window.innerHeight );
	scn.cam.aspect = window.innerWidth / window.innerHeight;
	scn.cam.updateProjectionMatrix();

	updateObjsPos();
	scn.brand.scale.setScalar( scn.brand.scalarV );
	if(scn.moving == true){	
		scn.brand.position.x = scn.brand.mov.x;
		scn.brand.position.y = scn.brand.mov.y;
		scn.close.position.x = scn.close.mov.x;
		scn.close.position.y = scn.close.mov.y;
		scn.carousel.position.x = 0;
		scn.carousel.position.y = scn.carousel.mov.y;
		for(let i = 0; i < scn.carousel.children.length; i++){
			scn.carousel.children[i].position.x = scn.carousel.radius * Math.sin(scn.carousel.angle*i);
			scn.carousel.children[i].position.z = scn.carousel.radius * Math.cos(scn.carousel.angle*i);
			scn.carousel[scn.carousel.children[i].name] = scn.carousel.angle*i;
			scn.carousel.children[i].scale.setScalar( scn.carousel.cScale );
		}
	}
	if(scn.moving == false){
		scn.brand.position.x = scn.brand.lock.x;
		scn.brand.position.y = scn.brand.lock.y;
		scn.close.position.x = scn.close.lock.x;
		scn.close.position.y = scn.close.lock.y;
		scn.carousel.position.y = scn.carousel.lock.y;
	}
}
function updateObjsPos(){
	if(scn.moving == true){
		scn.camViewSize = calcViewSize(scn.cam, scn.camMov.z, 0, 0);
		scn.refSCaleY = Math.trunc((scn.camViewSize.y*scn.cam.aspect)*100)/100;
		scn.refSCaleX = Math.trunc((scn.camViewSize.x*scn.cam.aspect)*100)/100;
		scn.brand.scalarV = clamp(scn.refSCaleY/68, 0.6, 1.2);
	}
	if(scn.moving == false){
		scn.camViewSize = calcViewSize(scn.cam, scn.camLock.z, 0, 0);
		scn.refSCaleY = Math.trunc((scn.camViewSize.y*scn.cam.aspect)*100)/100;
		scn.refSCaleX = Math.trunc((scn.camViewSize.x*scn.cam.aspect)*100)/100;
		scn.brand.scalarV = clamp(scn.refSCaleY/160, 0.8, 1.5);
	}
	scn.brand.mov = { x: 0, y: clamp( scn.camViewSize.y, 0, 8 ) };
	scn.brand.lock = { x: -scn.camViewSize.x/2 + scn.brand.bb.x, y: scn.camViewSize.y/2 - scn.brand.bb.y }; 
	scn.close.scale.setScalar( scn.brand.scalarV );
	scn.close.mov = { x: scn.camViewSize.x, y: scn.brand.lock.y };
	scn.close.lock = { x: -scn.brand.lock.x, y: scn.brand.lock.y };

	scn.carousel.radius = clamp( scn.refSCaleY/2, 2, 36 );
	scn.carousel.angle = Math.trunc(( (Math.PI/180 * 360)/scn.carousel.children.length)*100)/100;
	scn.carousel.cScale = clamp(scn.brand.scalarV*4, 0.6, 4) ;
	scn.carousel.mov = {y: -scn.brand.mov.y};
	scn.carousel.lock = {y: scn.camViewSize.y/2 - scn.brand.lock.y/2};
}
function onPointerMove( event ) {
	if(scn.moving == true){
		event.preventDefault();
		scn.v2.x = ( event.clientX / window.innerWidth ) * 2 - 1;
		scn.v2.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
		scn.raycaster.setFromCamera( scn.v2, scn.cam );
		scn.intersects = scn.raycaster.intersectObjects( scn.intersectedObjs, false );
		if ( scn.intersects.length > 0 ) {
			let animeArray = [];
			scn.intersected = scn.intersects[0].object;
			if(scn.currentIntersected == null){
				//'new'			
				scn.currentIntersected = scn.intersected;
				changeColor(scn.currentIntersected.children[0], "hover" );
				animeItem(scn.currentIntersected, 'scale', ['x','y'], [scn.carousel.cScale*1.6,scn.carousel.cScale*1.6], 0.5);
			}
			if(scn.intersected.name !== scn.currentIntersected.name){
				//'changed'
				scn.currentIntersected = scn.intersected;
				changeColor(scn.currentIntersected.children[0], "hover");
				animeItem(scn.intersected, 'scale', ['x','y'], [scn.carousel.cScale*1.6,scn.carousel.cScale*1.6], 0.5);
				for(let i = 0; i < scn.carousel.children.length; i++){
					if(scn.carousel.children[i].name != scn.intersected.name){
						changeColor(scn.carousel.children[i].children[0], "normal");
						animeItem(scn.carousel.children[i], 'scale', ['x','y'], [scn.carousel.cScale,scn.carousel.cScale], 0.5);
					}
				}
			}
		}
		if ( scn.intersects.length == 0 ) {
			if(scn.currentIntersected != null){
				let animeArray = [];
				//'none'
				for(let i = 0; i < scn.carousel.children.length; i++){
					changeColor(scn.carousel.children[i].children[0], "normal");
					animeItem(scn.carousel.children[i], 'scale', ['x','y'], [scn.carousel.cScale,scn.carousel.cScale], 0.5);
				}
				scn.currentIntersected = null;
			}
		}
	}
}
function animeItem(item, property, paramArr, endVArr, duration, delay=0, endAction=null, ease=easeInOutQuad){
	duration = Math.trunc((duration + delay) * scn.raf.fpsD);
	for (let i = 0; i < paramArr.length; i++){
		let startV = item[property][paramArr[i]];
		let deltaV = endVArr[i] - startV;
		if(i > 0){endAction = null}
		scn.renderGroup.push( [ scn.raf.currFrame, duration, item, property, [paramArr[i]], ease, startV, deltaV, endVArr[i], endAction ] );
	}
	return;
}
function animate() {				
	scn.raf.fpsInterval = scn.raf.currT - scn.raf.prevT;
	if(scn.raf.fpsInterval > scn.raf.fpsD){
		scn.raf.prevT = scn.raf.currT;
		render();
	}
	scn.raf.currT += scn.raf.fps;
	requestAnimationFrame(animate);
}
function render(){
	scn.raf.currFrame++;
	if(scn.moving){ rotateCarousel( scn.carousel, scn.cam ); }
	for (let i = 0; i < scn.carousel.children.length; i++){
		scn.carousel.children[i].lookAt( scn.cam.position );
	}
	for(let i = 0; i < scn.renderGroup.length; i++){
		// [ startFrame, duration(seconds), item, property, param, ease, startV, deltaV, endV, endAction ]
		scn.raf.motionCount = scn.raf.currFrame - scn.renderGroup[i][0];
		if(scn.raf.motionCount >= scn.renderGroup[i][1]){
			scn.renderGroup[i][2][scn.renderGroup[i][3] ][scn.renderGroup[i][4] ] = scn.renderGroup[i][8];
			if(scn.renderGroup[i][9]){
				scn.renderGroup[i][9]();
			}
			scn.renderGroup.splice(i, 1);
			continue;
		}
		scn.renderGroup[i][2][scn.renderGroup[i][3] ][scn.renderGroup[i][4] ] = Math.trunc(scn.renderGroup[i][5](scn.raf.motionCount, scn.renderGroup[i][6], scn.renderGroup[i][7], scn.renderGroup[i][1])*100 )/100;			
	}
	scn.controls.update();
	scn.renderer.render( scn, scn.cam );
}

function onPointerDown( event )  {
	scn.pointer.x = ( event.clientX / window.innerWidth ) * 2 - 1;
	scn.pointer.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
	scn.raycaster.setFromCamera( scn.pointer, scn.cam );
	scn.intersects = scn.raycaster.intersectObjects( scn.intersectedObjs, false );
	if ( scn.intersects.length > 0 ) {
		event.preventDefault();
		scn.currentIntersected = scn.intersects[0].object;
		if(scn.moving == true){
			scn.intersectedObjs = scn.topicRays;
			console.log(scn.menuObjs[scn.currentIntersected.name].loaded)
			if(scn.menuObjs[scn.currentIntersected.name].loaded == false){
				loadFiles( [ scn.menuObjs[scn.currentIntersected.name] ], openInfo );
			}
			openInfo();
			return;
		}
		if(scn.moving == false){
			if(scn.currentIntersected.name == "close"){
				scn.intersectedObjs = scn.carouselRays;
				closeInfo();
				return; 
			}
			if(scn.currentIntersected.name == "rayLink"){
				linkPage(scn.currentIntersected.url);
			}
		}
	}
}
function keyDownEvent( event ){
	if (event.key === "ArrowUp") {
		scrollScreen( -3.4, scn );
	}
	if (event.key === "ArrowDown") {
		scrollScreen( 3.4, scn );
	}
}
function wheelEvent( event ){
	scrollScreen( event.deltaY/20, scn );
}
function onTouchStart( event ){
	scn.cam.eventPosY = event.touches[ 0 ].pageY;
}
function onTouchMove( event ){
	let speed = 0.01;
	let deltaY = -( event.touches[ 0 ].pageY - scn.cam.eventPosY );
	scrollScreen( deltaY * speed, scn );
}
function scrollScreen( scrollV ){
	if( scn.moving == false ){
		scn.cam.position.y -= scrollV;
		scn.controls.target.y -= scrollV;
		if(scn.cam.position.y >= scn.cam.topLimit ){
			scn.cam.position.y = scn.cam.topLimit;
			scn.controls.target.y = scn.cam.topLimit;
		}
		if(scn.cam.position.y <= scn.cam.bottomLimit ){
			scn.cam.position.y = scn.cam.bottomLimit;
			scn.controls.target.y = scn.cam.bottomLimit;
		}
	}
}
function genRaycastMesh(rayW, rayH){
	const rayGeo = new PlaneGeometry( rayW, rayH );
	const rayMat = new MeshBasicMaterial( {color: "#000000", visible: false, side: FrontSide} );
	const rayMesh = new Mesh( rayGeo, rayMat );
	rayGeo.dispose();
	rayMat.dispose();
	return rayMesh;
}
function generateImg(texture){
	texture.colorSpace = SRGBColorSpace;
	let width = texture.source.data.width;
	let height = texture.source.data.height;
	let geometry = new PlaneGeometry( width, height );
	geometry.computeBoundingBox();
	geometry.translate(width/2, -height/2, 0);
	let material = new MeshBasicMaterial( {map: texture, opacity: 0, transparent: true, fog: false} );
	let mesh = new Mesh( geometry, material );
	geometry.dispose();
	material.dispose();
	texture.dispose();
	mesh.bb = {w:width, h:height}
	mesh.aspect = Math.trunc((width/height)*100)/100;
	mesh.scale.normalize();
	return mesh;
}
function generateVid(data){
	const texture = new VideoTexture( data );
	texture.colorSpace = SRGBColorSpace;
	//let width = data.videoWidth;
	//let height = data.videoHeight;
	let width = data.width;
	let height = data.height;
	let geometry = new PlaneGeometry( width, height );
	geometry.computeBoundingBox();
	geometry.translate(width/2, -height/2, 0);
	let material = new MeshLambertMaterial( {map: texture, opacity: 0, transparent: true, fog: false} );
	let mesh = new Mesh( geometry, material );
	mesh.scale.normalize();
	mesh.bb = {w:width, h:height}
	mesh.aspect = Math.trunc((width/height)*100)/100;
	//mesh.name = "video";
	mesh.vidElement = data;
	mesh.vidElement.play();
	geometry.dispose();
	material.dispose();
	texture.dispose();
	return mesh;
}
function generateSvg(data){
	let width = parseFloat(data.xml.attributes.width.nodeValue);
	let height = parseFloat(data.xml.attributes.height.nodeValue);
	const geo = new PlaneGeometry( width, height );
	geo.computeBoundingBox();
	geo.translate(width/2, -height/2, 0);
	const mat = new MeshBasicMaterial( {color: "#000000", visible: false, side: FrontSide, fog: false} );
	const groupMesh = new Mesh(geo, mat);
	geo.dispose();
	mat.dispose();
	groupMesh.bb = {w:width, h:height};
	groupMesh.aspect = Math.trunc((width/height)*100)/100;
	//groupMesh.material = {opacity: 0};
	let renderOrder = 2;
	for ( const path of data.paths ){
		const fillColor = path.userData.style.fill;
		if ( fillColor !== undefined && fillColor !== 'none' ) {
			const material = new MeshPhongMaterial( {
				color: new Color().setStyle( fillColor ),
				opacity: 0,
				transparent: true,
				fog: false,
				side: FrontSide,
				depthWrite: false,
				wireframe: false
			} );
			const shapes = SVGLoader.createShapes( path );
			for ( const shape of shapes ) {
				const geometry = new ShapeGeometry( shape );
				geometry.computeBoundingBox();
				const mesh = new Mesh( geometry, material );
				mesh.scale.y *= -1;
				mesh.renderOrder = renderOrder++;
				groupMesh.add( mesh );
				material.dispose();
				geometry.dispose();
			}
		}
		const strokeColor = path.userData.style.stroke;
		if (strokeColor !== undefined && strokeColor !== 'none' ) {
			const material = new MeshPhongMaterial( {
				color: new Color().setStyle( strokeColor ),
				opacity: 1,
				transparent: true,
				fog: false,
				side: FrontSide,
				depthWrite: false,
				wireframe: false
			} );
			for ( const subPath of path.subPaths ) {
				const geometry = SVGLoader.pointsToStroke( subPath.getPoints(), path.userData.style );
				geometry.computeBoundingBox();
				if ( geometry ) {
					const mesh = new Mesh( geometry, material );
					mesh.scale.y *= -1;
					mesh.renderOrder = renderOrder++;
					groupMesh.add( mesh );
					material.dispose();
					geometry.dispose();
				}
			}
		}
	}
	groupMesh.scale.normalize();
	return groupMesh;
}
function alignTextBlock(wordsArr, colW, fontSize){
	let wordCueX = 0;
	let textLine = "";
	fontSize = Math.floor((fontSize/2.5)*100)/100; // case of fontSize less than 1
	colW = Math.ceil(colW*100)/100;
	let lineChars = Math.ceil(colW/fontSize);
	for (let i = 0; i < wordsArr.length; i++){
		if(i == wordsArr.length-1){
			if( wordCueX + wordsArr[i].length > lineChars ) {
				textLine += "\n";
			}
			textLine += wordsArr[i];
			return textLine;
		}
		if( wordCueX < lineChars ) {
			textLine += wordsArr[i];
			wordCueX += (wordsArr[i].length);
		}
		if( wordCueX + 1 >= lineChars || wordCueX + 1 + wordsArr[i+1].length > lineChars ) {
			textLine += "\n";
			wordCueX = 0;
			continue;
		}
		if( wordCueX + 1 < lineChars ) {
			textLine += " ";
			wordCueX += 1;
		}
	}
}
function generateText(textContent, fontStyle, fontSize){
	let geometry = new TextGeometry( textContent, {
		font: fontStyle,
		size: fontSize,
		height: 0.0,
		depth: 0.0,
		curveSegments: 1,
		bevelEnabled: false,
		bevelThickness: 0,
		bevelSize: 0,
	} );
	geometry.clearGroups();
	geometry.computeBoundingBox();
	geometry.computeVertexNormals();
	let width = Math.trunc( Math.abs(geometry.boundingBox.min.x - geometry.boundingBox.max.x) *100)/100 ;
	let height = Math.trunc( Math.abs(geometry.boundingBox.min.y - geometry.boundingBox.max.y) *100)/100 ;
	//geometry.translate(-width/2, 0, 0);
	let textMat = new MeshBasicMaterial( { color: "#04453A", transparent: true, fog: false } );
	let textMesh = new Mesh( geometry, textMat );
	textMesh.bb = {w:width, h:height};
	textMesh.material.opacity = 0;

	textMesh.scale.normalize();

	geometry.dispose();
	textMat.dispose();
	return textMesh;
}
function linkPage(url){
	window.open(url); 
}
function calcViewSize(camera, depth, vX, vY){
	return camera.getViewSize(depth, scn.v2.set(vX, vY) );
}
function rotateCarousel(obj, camera){
	if(obj.rotation.y >= Math.PI*2){
		obj.rotation.y = obj.rotation.y - Math.PI*2;
	}
	if(obj.rotation.y < 0){
		obj.rotation.y = obj.rotation.y + Math.PI*2;
	}
	obj.rotation.y -= camera.position.x/500 + 0.002;
}
function setScene(){
	scn.raf = setRAF(30);
	scn.moving = true;
	scn.currentIntersected = null;
	scn.pointer = new Vector2();
	scn.raycaster = new Raycaster();
	scn.intersectedObjs = [];
	scn.carouselRays = [];
	scn.topicRays = [];
	scn.renderGroup = [];
	scn.v2 = new Vector2();
	scn.renderer = setRenderer();
	scn.animeArray = [];
	scn.camMov = { x:0, y:24, z:80 };
	scn.camLock = { x:0, y:0, z:160 };
	scn.tgtMov = { x:0, y:2, z:0 } ;	
	scn.tgtLock = { x:0, y:0, z:-20 };
	scn.cam = setCamera();
	scn.controls = setControls();
	scn.cam.lights = setLights();
	
	scn.colors = {
		stroke: { 
			"normal": {r: 0.004, g: 0.042, b: 0.036 },
			"hover": {r: 0.006, g: 0.08, b: 0.06 },
			"active": {r: 0.006, g: 0.08, b: 0.05 }
		},
		fill: {
			"normal": {r: 0.024, g: 0.57, b: 0.41 }, 
			"hover": {r: 0.1, g: 0.72, b: 0.4 },
			"active": {r: 0.1, g: 0.72, b: 0.7 }
		},
		glow: {
			"normal": {r: 0.033, g: 0.830, b: 0.597 }, 
			"hover": {r: 0.5, g: 0.9, b: 0.8},
			"active": {r: 0.9, g: 1.0, b: 0.9 }
		}
	}
	return scn;
}
function setRenderer(){
	let renderer = new WebGLRenderer( { canvas: document.querySelector("canvas"), antialias: true, alpha: true, precision: "highp" } );
	renderer.setPixelRatio( window.devicePixelRatio );
	renderer.setSize( window.innerWidth, window.innerHeight );
	renderer.shadowMap.enabled = false;
	renderer.domElement.style.position = 'absolute';
	renderer.domElement.style.top = 0;
	renderer.toneMapping = ACESFilmicToneMapping;
	renderer.toneMappingExposure = 1;
	renderer.autoClear = false;
	return renderer;
}
function setCamera(){
	let camera = new PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 10, 400  );
	camera.position.set( scn.camMov.x, scn.camMov.y, scn.camMov.z );	
	scn.add( camera );
	return camera;
}
function setControls(){
	let controls = new OrbitControls( scn.cam, scn.renderer.domElement ); 
	controls.rotateSpeed = 0.2;
	controls.target.copy( scn.tgtMov );

	controls.maxPolarAngle = 1.8;
	controls.minPolarAngle = 1.0;
	controls.minDistance = 16;
	controls.maxDistance = scn.camMov.z;	
	controls.minAzimuthAngle = -0.5;
	controls.maxAzimuthAngle = 0.5;
	controls.minZoom = 14;
	controls.maxZoom = scn.camMov.z;

	controls.enableDamping = true;				
	controls.dampingFactor = 0.1;
	controls.enablePan = false;
	return controls;
}
function setLights(){
	let light = new DirectionalLight( 0xFEFEFE, 3 );
	light.position.set( 0, 12, 28 );
	scn.cam.add( light );
	return light;
}
function setCarousel(){
	let carousel = new Group();
	carousel.scale.normalize();
	scn.add(carousel);
	return carousel;
}
function setInfoContainer(){
	let infoContainer = new Group();
	infoContainer.position.set(0, 0, 0);
	infoContainer.h2 = {fontSize: 0, fontFamily: scn.fonts.rubick.topics[0].media[0].data[1].src}
	infoContainer.p = {fontSize: 0, fontFamily: scn.fonts.rubick.topics[0].media[0].data[0].src}
	infoContainer.contentHeight = 0;
	
	let infoBlock = new Group();
	infoContainer.add( infoBlock );
	infoContainer.infoBlock = infoBlock;
	
	let infoTableGeo = new PlaneGeometry( 1, 1 );
	let infoTableMat = new MeshPhongMaterial( { color: 0x33EBCB, flatShading: true ,transparent: false, fog: false } );
	let infoTable = new Mesh( infoTableGeo, infoTableMat );
	infoTableGeo.dispose();
	infoTableMat.dispose();
	let infoTableEdge = new EdgesGeometry(infoTableGeo.geometry);
	let infoTableEdgeMat = new MeshPhongMaterial( { color: 0x0E3F36, flatShading: true ,transparent: false, fog: false } );
	let infoTableEdgeLine = new LineSegments(infoTableEdge, infoTableEdgeMat ); 
	infoTableEdge.dispose();
	infoTableEdgeMat.dispose();
	infoTable.add( infoTableEdgeLine );
	infoContainer.add( infoTable );
	infoContainer.infoTable = infoTable;
	infoTable.geometry.computeBoundingBox();
	infoTable.scale.normalize();
	infoTable.renderOrder = 0;
	infoTable.scale.y = 0.5;
	infoTable.position.set(0, 0, -0.01);								
	infoTable.visible = false;
	scn.add( infoContainer );
	return infoContainer;
}
function changeColor(obj, mode){
	obj.traverse(function(child){
		animeItem(child.material, 'color', ['r', 'g', 'b'], [ scn.colors[child.name][mode].r, scn.colors[child.name][mode].g, scn.colors[child.name][mode].b], 0.5);
	});
}
function clamp(val, min, max) {
    return Math.trunc( (val > max ? max : val < min ? min : val) * 100) / 100;
}


function setRAF(fps){
	return { fps: fps, fpsD: Math.round( 1000/fps ), currFrame: 0, currT: 0, prevT: 0, fpsInterval: 0, motionCount: 0}
}
function easeInOutQuad(t, b, c, d) {
	if ((t /= d / 2) < 1) return c / 2 * t * t + b;
	return -c / 2 * ((--t) * (t - 2) - 1) + b;
}
init();
</script>
</body>
</html>
