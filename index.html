<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes, minimum-scale=1.0, maximum-scale=5.0">		
	<title>Funilaria Digital</title>
	<meta name="author" content="funilariadigital">
	<link rel="apple-touch-icon" sizes="180x180" href="./media/icon/favicon/apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="./media/icon/favicon/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="./media/icon/favicon/favicon-16x16.png">
	<link rel="manifest" href="./media/icon/favicon/site.webmanifest">
	<link rel="stylesheet" href="./static/css/pages/base.css">
</head>
<body>
<canvas id="canvas"></canvas>
<div id="container" class="invisible">
	<div id="3d" class="contentBlock">
		<div class="topicBlock">
			<div data-width="100" data-order="0" data-type="media">
				<a href="https://funilariadigital.com.br/art-gallery-display/" target="_blank" >
					<noscript>
					<video width="462" height="260" title="Art Gallery Display" muted loop>
						<source src="./media/3d/vid/mobile/Art-Gallery-Display.mp4" type="video/mp4">
					</video>
					</noscript>
				</a>
				<a href="https://funilariadigital.com.br/open-map-scenario/" target="_blank" >
					<noscript>
					<video width="462" height="260" title="3D open map scenario" muted loop>
					<source src="./media/3d/vid/mobile/Open-Map-Scenario.mp4" type="video/mp4">
					</video>
					</noscript>
				</a>
			</div>
		</div>
		<div class="topicBlock">
			<div data-width="100" data-order="0" data-type="text">
				<h2>Interactive 3D Projects</h2>
				<p>Pipeline align, Webgl mesh refactor. Transpile heavy rendered projects to real time, all available platforms. Fallbacks for a robust build.</p>
			</div>
		</div>
		<div class="topicBlock">
			<div data-width="60 "data-order="0" data-type="text">
				<h2>Clients and Workforce Visualized</h2>
				<p>Enhance daily tasks, sales presentation, point-of-sale display, team briefing. Easy to use resources at hand.</p>
			</div>
			<div data-width="38" data-order="1" data-type="media">
			<a href="https://funilariadigital.com.br/object-3d-menu/" target="_blank" >
				<noscript>
				<img src="./media/3d/picture/mobile/3d-shape-mesh-menu.webp" alt="3d-shape-mesh-menu" />
				</noscript>
			</a>
			<noscript>
			<img src="./media/3d/picture/mobile/cad-blueprint-projection.webp" alt="cad-blueprint-projection" />
			</noscript>
			</div>
		</div>
		<div class="topicBlock">
			<div data-width="44" data-order="0" data-type="text">
				<h2>Graphic Layer Only</h2>
				<p>Dynamic or static display done with regular HTML/XML inputs. Preview integrity preserved on improvement updates.</p>
			</div>
			<div data-width="54" data-order="1" data-type="text">
				<h2>Product Immersion by Refresh Rate</h2>
				<p>3D available for market strategies and business tools. A medium to provide consumers be part of what they are interested.</p>
			</div>
		</div>
		<div class="topicBlock">
			<div data-width="100" data-order="0" data-type="media">
				<noscript>
				<img src="./media/3d/picture/mobile/solar-system-model-3d.webp" alt="solar-system-model-3d" />
				</noscript>
				<noscript>
				<img src="./media/3d/picture/mobile/rigging-setup-character.webp" alt="rigging-setup-character" />
				</noscript>
			</div>
		</div>
	</div>
	<div id="ux" class="contentBlock">
		<div class="topicBlock">
			<div data-width="100" data-order="0" data-type="text">
				<h2>Any Screen Size Responsive</h2>
				<p>Fast layout adjust, dynamic information formatted on the fly. Render the exact resolution to each user. Ideal experience for humans and robots.</p>
			</div>
		</div>
		<div class="topicBlock">
			<div data-width="50" data-order="1" data-type="text">
				<h2>Customized Templates on Demmand</h2>
				<p>Convenient user access on what matters. Unique shapes and widgets made for every job. Original medias presented to the audience.</p>
			</div>
			<div data-width="34" data-order="0" data-type="media">
				<noscript>
				<img src="./media/ux/picture/mobile/custom-professional-ux.webp" alt="custom-professional-ux" />
				</noscript>
				<noscript>
				<img src="./media/ux/picture/mobile/photo-overlay-ux.webp" alt="photo-overlay-ux" />
				</noscript>
			</div>
		</div>
		<div class="topicBlock">
			<div data-width="50" data-order="0" data-type="text">
				<h2>Logic Over Third Parties</h2>
				<p>Strict native script features. Vanilla JS, HTML and CSS. Less libraries overhead or multi featured addons. Know whats happening in all lines.</p>
			</div>
			<div data-width="48" data-order="1" data-type="text">
				<h2>Useful Responsive Layouts</h2>
				<p>Improve feedback insights by an easy to see interface. Figure which strategies are doing positive results and what needs update.</p>
			</div>
		</div>
		<div class="topicBlock">
			<div data-width="100" data-order="0" data-type="media">
				<noscript>
				<img src="./media/ux/vector/javascript-logo.svg" width="40" height="40" alt="javascript-logo" />
				</noscript>
				<noscript>
				<img src="./media/ux/vector/webgl-logo.svg" width="95" height="40" alt="webgl-logo" />
				</noscript>
				<noscript>
				<img src="./media/ux/vector/python-logo.svg" width="164" height="40" alt="python-logo" />
				</noscript>
				<noscript>
				<img src="./media/ux/vector/css3-logo.svg" width="28" height="40" alt="css3-logo" />
				</noscript>
			</div>
		</div>
	</div>
	<div id="img" class="contentBlock">
		<div class="topicBlock">
			<div data-width="100" data-order="0" data-type="media">
				<noscript>
				<video width="462" height="260" title="Sun Timelapse" muted loop>
					<source src="./media/img/vid/mobile/sun-timelapse.mp4" type="video/mp4">
				</video>
				</noscript>
				<noscript>
				<video width="462" height="260" title="Drone Aerial Take" muted loop>
					<source src="./media/img/vid/mobile/drone-aerial.mp4" type="video/mp4">
				</video>
				</noscript>
			</div>
		</div>
		<div class="topicBlock">
			<div data-width="100" data-order="0" data-type="text">
				<h2>Media Output Profiles Render</h2>
				<p>Quality files processed for screen sizes. Fast loading time, color fidelity, smooth organic shapes, fluid animations.</p>
			</div>
		</div>
		<div class="topicBlock">
			<div data-width="64" data-order="0" data-type="text">
				<h2>Audience Range Achieved Through Performance</h2>
				<p>Up to date format standards display art and documents at the right medium. Correct measures means less bounces, positive user experience.</p>
			</div>
			<div data-width="32" data-order="1" data-type="media">
				<noscript>
				<img src="./media/img/picture/mobile/night-sky.webp" alt="night-sky" />
				</noscript>
			</div>
		</div>
		<div class="topicBlock">
			<div data-width="64" data-order="1" data-type="text">
				<h2>Indexed Media Versions Routine</h2>
				<p>Batch process versatile formats by devices required. Aspect ratio, connection bandwidth, bit rates carefuly revised for publishing.</p>
			</div>
			<div data-width="32" data-order="0" data-type="media">
				<noscript>
				<img src="./media/img/picture/mobile/uv-ligh-paint-gueixa.webp" alt="uv-ligh-paint-gueixa" />
				</noscript>
			</div>
		</div>
		<div class="topicBlock">
			<div data-width="50" data-order="0" data-type="text">
				<h2>Better Ranks with Best Practices</h2>
				<p>Search engines, social media alghoritms, web analytics prevails fit medias. A lean payload saves time, agregate crawlers priority points.</p>
			</div>
			<div data-width="32" data-order="1" data-type="media">
				<noscript>
				<img src="./media/img/picture/mobile/lord-cat-pose.webp" alt="lord-cat-pose" />
				</noscript>
				<noscript>
				<img src="./media/img/picture/mobile/dogs-ocean.webp" alt="dogs-ocean" />
				</noscript>
			</div>
		</div>
	</div>
	<div id="seo" class="contentBlock">
		<div class="topicBlock">
			<div data-width="100" data-order="0" data-type="text">
				<h2>Profit From Relevant Insights</h2>
				<p>Automate apps to monitor business activities. Specialized tools capable to feed, manipulate, rearrange it's parameters, narrow objectives.</p>
			</div>
		</div>
		<div class="topicBlock">
			<div data-width="100" data-order="0" data-type="media">
				<noscript>
				<img src="./media/seo/vector/engagement-statistic-analysis.svg" alt="engagement-statistic-analysis" />
				</noscript>
			</div>
		</div>
		<div class="topicBlock">
			<div data-width="48" data-order="0" data-type="text">
				<h2>Efficient Data Classify</h2>
				<p>Gather massive sorted data. Intuitive easy to feed, clear to visualize. Strategies built from current feedbacks.</p>
			</div>
			<div data-width="50" data-order="1" data-type="text">
				<h2>Wise Planning Approach</h2>
				<p>Measure consumer engagement by an one to many app. Tools to monitor whats new, what is still providing results and what should be replaced.</p>
			</div>
		</div>
		<div class="topicBlock">
			<div data-width="100" data-order="0" data-type="media">
				<noscript>
				<img src="./media/seo/vector/consumer-audience-monitoring.svg" alt="consumer-audience-monitoring" />
				</noscript>
			</div>
		</div>
		<div class="topicBlock">
			<div data-width="100" data-order="0" data-type="text">
				<h2>Reviews Awareness</h2>
				<p>Audience monitoring automations. Official available data cross referenced on different sources. Search rank valuable method.</p>
			</div>
		</div>
	</div>
	<div id="api" class="contentBlock">
		<div class="topicBlock">
			<div data-width="100" data-order="0" data-type="text">
				<h2>Integrate Existent Interface Apps</h2>
				<p>Sales, workflow, optimization of any kind to enhance relations. New data sources from respected reputation service providers.</p>
			</div>
		</div>
		<div class="topicBlock">
			<div data-width="100" data-order="0" data-type="media">
				<noscript>
				<img src="./media/api/vector/workflow-convenience.svg" alt="workflow-convenience" />
				</noscript>
			</div>
		</div>
		<div class="topicBlock">
			<div data-width="50" data-order="0" data-type="text">
				<h2>Tools You Already Work</h2>
				<p>Most Saas providers offers a complete interface usage. Onboard internal presets with custom tools available. Accessed by latest security procedures.</p>
			</div>
			<div data-width="48" data-order="1" data-type="text">
				<h2>Multiple Sources Data Feed</h2>
				<p>Bundles mounted at the business desired specs. With buit in cross provider hooks, officialy registered. Live, safe, legal.</p>
			</div>
		</div>
		<div class="topicBlock">
			<div data-width="100" data-order="0" data-type="media">
				<noscript>
				<img src="./media/api/vector/application-cross-reference.svg" alt="application-cross-reference" />
				</noscript>
			</div>
		</div>
		<div class="topicBlock">
			<div data-width="24" data-order="0" data-type="text">
				<h2>Unified Social Media Manage</h2>
				<p>Media brands have APIs allowed to interact. Social medias, websites, analytics, apps, converged to one assistance asset.</p>
			</div>
			<div data-width="60" data-order="1" data-type="media">
				<noscript>
				<img src="./media/api/picture/mobile/api-google-maps-gps-track.webp" alt="api-google-maps-gps-track" />
				</noscript>
				<noscript>
				<img src="./media/api/picture/mobile/api-google-maps-data-overlay.webp" alt="api-google-maps-data-overlay" />
				</noscript>
				<noscript>
				<img src="./media/api/vector/social-media-integrate.svg" alt="social-media-integrate" />
				</noscript>
			</div>
		</div>
	</div>
	<div id="info" class="contentBlock">
		<div class="topicBlock">
			<div data-width="100" data-order="0" data-type="media">
				<noscript>
				<img src="./media/info/picture/mobile/about-rodrigo-achcar.webp" alt="about-rodrigo-achcar" />
				</noscript>
			</div>
		</div>
		<div class="topicBlock">
			<div data-width="100" data-order="0" data-type="text">
				<h2>Rodrigo Rodrigues Achcar</h2>
				<p>3D Specialist (Autodesk Maya, DRC São Paulo). Mesh set up for animation, rigging, is my thing. As time went by got media production and coding jobs, service auctions disputes.</p>
				<p>Such jobs opportunities provided skills on media post-production, rendering, batch documents and medias reprocess, interactive resources, 2D and 3D animation styles, aerial captures, geopositioned orthomosaic maps.</p>
				<p>Since some time was required monitoring auction posts, I've begin to code automations to feed, sort by interest, database input and content views.</p>
				<p>After that I went for ECMA scripts and focus on graphic layer coding jobs. Medias, UX, WebGL, APIs, SEOs.</p>
			</div>
		</div>
		<div class="topicBlock">
			<div data-width="100" data-order="0" data-type="media">
				<a href="https://www.linkedin.com/in/rodrigo-achcar/" target="_blank" >
				<noscript>
				<img src="./media/info/vector/linkedin-rodrigo-achcar.svg" alt="linkedin-rodrigo-achcar" />
				</noscript>
				</a>
				<a href="https://github.com/RodrigoAchcar" target="_blank" >
				<noscript>
				<img src="./media/info/vector/github-rodrigo-achcar.svg" alt="github-rodrigo-achcar" />
				</noscript>
				</a>
				<a href="https://wa.me/5561992720142" >
				<noscript>
				<img src="./media/info/vector/whatsapp-phone-rodrigo-achcar.svg" alt="whatsapp-phone-rodrigo-achcar" />
				</noscript>
				</a>
				<a href="https://www.facebook.com/rodrigo.achcar.9/" target="_blank" >
				<noscript>
				<img src="./media/info/vector/facebook-rodrigo-achcar.svg" alt="facebook-rodrigo-achcar" />
				</noscript>
				</a>
				<a href="https://www.instagram.com/rodrigorachcar/" target="_blank" >
				<noscript>
				<img src="./media/info/vector/instagram-rodrigo-achcar.svg" alt="instagram-rodrigo-achcar" />
				</noscript>
				</a>
				<a href="mailto:rodrigor.achcar@gmail.com" target="_blank" >
				<noscript>
				<img src="./media/info/vector/email-contact.svg" alt="email-contact" />
				</noscript>
				</a>
			</div>
		</div>
	</div>
</div>
<script type="importmap">
	{
		"imports": {
			"three": "./static/js/webgl/build/three.module.js",
			"three/addons/": "./static/js/webgl/jsm/"
		}
	}
</script>
<script type="module">
import { Cache, WebGLRenderer, ACESFilmicToneMapping, Color, SRGBColorSpace, Vector2, Vector3, Scene, PerspectiveCamera, DirectionalLight, Group, Raycaster, LoadingManager, TextureLoader, VideoTexture, Mesh, MeshStandardMaterial, MeshBasicMaterial, MeshLambertMaterial, MeshPhongMaterial, PlaneGeometry, ShapeGeometry, EdgesGeometry, LineSegments, FrontSide } from 'three';
import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';	
import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
import { Font } from 'three/addons/loaders/FontLoader.js';
import { TTFLoader } from 'three/addons/loaders/TTFLoader.js';
import { SVGLoader } from 'three/addons/loaders/SVGLoader.js';
Cache.enabled = true;
const scn = new Scene();
const requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;
const cancelAnimationFrame = window.cancelAnimationFrame || window.mozCancelAnimationFrame;
function init(){
	setScene(scn);
	loadFiles( [ scn.fonts.rubick, scn.meshes.homepage ] , getMenuItems);
}
function loadFile(loaderClass, filePath) {
	return new Promise((resolve) => {
		const loader = loaderClass;
		loader.load(filePath, (data) => {
			resolve(data);
		});
	});
}
async function loadFiles( filesArray, endAction=null ){
	const manager = new LoadingManager();
	let filesLoadQtd = 0;
	let loadCount = 0;
	for(let i = 0; i < filesArray.length; i++){
		for(let j = 0; j < filesArray[i].topics.length; j++){
			if(filesArray[i].topics[j].media){
				for(let k = 0; k < filesArray[i].topics[j].media.length; k++){
					for(let l = 0; l < filesArray[i].topics[j].media[k].data.length; l++){
						if(filesArray[i].topics[j].media[k].data[l].tag !== 'mp4'){
							filesLoadQtd++;
						}
					}
				}
			}
		}
	}
	for(let i = 0; i < filesArray.length; i++){
		for(let j = 0; j < filesArray[i].topics.length; j++){
			if(filesArray[i].topics[j].media){
				for(let k = 0; k < filesArray[i].topics[j].media.length; k++){
					for(let l = 0; l < filesArray[i].topics[j].media[k].data.length; l++){
						if(filesArray[i].topics[j].media[k].data[l].tag !== 'mp4'){
							let data = await loadFile(new scn.loaderClasses[filesArray[i].topics[j].media[k].data[l].tag][0](manager), filesArray[i].topics[j].media[k].data[l].src);
							filesArray[i].topics[j].media[k].data[l].src = data;
							
							if( filesArray[i].topics[j].media[k].data[l].tag == "webp" ){
								filesArray[i].topics[j].media[k].data[l].w = data.source.data.width;
								filesArray[i].topics[j].media[k].data[l].h = data.source.data.height;
								filesArray[i].topics[j].media[k].mediasW += data.source.data.width;
								filesArray[i].topics[j].media[k].mediasH += data.source.data.height;
							}
							if( filesArray[i].topics[j].media[k].data[l].tag == "svg" ){
								
								filesArray[i].topics[j].media[k].data[l].w = data.xml.width.baseVal.value;
								filesArray[i].topics[j].media[k].data[l].h = data.xml.height.baseVal.value;
								filesArray[i].topics[j].media[k].mediasW += data.xml.width.baseVal.value;
								filesArray[i].topics[j].media[k].mediasH += data.xml.height.baseVal.value;
								
							}
							if( filesArray[i].topics[j].media[k].data[l].tag == "ttf" ){
								filesArray[i].topics[j].media[k].data[l].src = new Font( data );
							}
							loadCount++;
						}
					}
				}
			}
		}
		filesArray[i].loaded = true;
	}
	if(loadCount == filesLoadQtd){
		//console.log('loading complete');
		endAction();
		return;
	}
	manager.onStart = function () {};
	manager.onProgress = function () {};
	manager.onLoad = function () {};
	manager.onError = function () {};
}
function getMenuItems(){
	const obj = {};
	const content = document.getElementById("container");
	for(let i = 0; i < content.children.length; i++){
		let menuItem = content.children[i];
		let itemID = menuItem.getAttribute("id");
		obj[itemID] = { loaded : false, topics: []};
		for(let j = 0; j < menuItem.children.length; j++){
			let topics = menuItem.children[j];
			let topicObj = { media: [], text: [] };
			for(let k = 0; k < topics.children.length; k++){
				let block = topics.children[k];
				let blockObj = { type: block.getAttribute("data-type"), order: block.getAttribute("data-order"), width: block.getAttribute("data-width"), data: [] };
				if( blockObj.type == 'media'){
					blockObj.mediasW = 0;
					blockObj.mediasH = 0;
				}
				for(let l = 0; l < block.children.length; l++){
					let elm = block.children[l];
					if( blockObj.type == 'text'){
						blockObj.data.push( { tag: elm.localName, info: elm.innerHTML.split(' ')} );
					}
					if( blockObj.type == 'media'){
						
						let dataObj = {};
						if(elm.localName == 'a'){
							dataObj.href = elm.getAttribute("href");
							elm = elm.children[0];
						}
						dataObj.src = elm.firstChild.textContent.match( /src="([^\"]+)/ )[1];
						dataObj.tag = dataObj.src.match( /(.+)\.(.+)$/ )[2];
						if(dataObj.tag == 'mp4'){
							const fragment = document.createRange().createContextualFragment(elm.firstChild.textContent).children[0];
							dataObj.src = fragment;
							dataObj.w = fragment.width;
							dataObj.h = fragment.height;
							blockObj.mediasW += fragment.width;
							blockObj.mediasH += fragment.height;

						}
						blockObj.data.push( dataObj );
					}
				}
				topicObj[blockObj.type].push(blockObj);
			}
			if(topicObj.media.length == 0){ delete topicObj.media;	}
			if(topicObj.text.length == 0){ delete topicObj.text; }
			obj[itemID].topics.push(topicObj);
		}
	}
	scn.menuObjs = obj;
	buildScenario();
	return;
}
function buildScenario(){
	scn.carousel = setCarousel();
	scn.infoC = setinfoC();
	for(let item of Object.values(scn.meshes.homepage.topics[0].media[0].data[0].src.children) ){
		let geo = item.geometry;
		let strokeMat = new MeshStandardMaterial( { color: new Color('#0E3F36'), fog: false, toneMapped: false, transparent: true } );
		let mesh = new Mesh(geo, strokeMat);
		geo.dispose();
		strokeMat.dispose();
		mesh.name = 'stroke';
		if(item.children.length > 0){
			let geoFill = item.children[0].geometry;
			let fillMat =  new MeshStandardMaterial( { color: new Color('#2BC7AC'), roughness: 1, metalness: 0, fog: false, toneMapped: false, transparent: true } );
			let meshFill = new Mesh(geoFill, fillMat);
			meshFill.name = 'fill';
			geoFill.dispose();
			fillMat.dispose();
			item.children[0].geometry.dispose();
			item.children[0].material.dispose();
			if(item.children[0].children.length > 0){
				let geoGlow = item.children[0].children[0].geometry;
				let glowMat = new MeshStandardMaterial( { color: new Color('#33EBCB'), roughness: 1, metalness: 0, fog: false, toneMapped: false, transparent: true } );
				let meshGlow = new Mesh(geoGlow, glowMat);
				meshGlow.name = 'glow';
				geoGlow.dispose();
				glowMat.dispose();
				meshFill.add(meshGlow);
			}
			mesh.add(meshFill);
		}
		mesh.scale.normalize();
		mesh.geometry.computeBoundingBox();
		mesh.geometry.computeBoundingSphere();
		mesh.bb = {x: Math.abs(mesh.geometry.boundingBox.min.x - mesh.geometry.boundingBox.max.x), y: Math.abs(mesh.geometry.boundingBox.min.y - mesh.geometry.boundingBox.max.y)}; 
		if(Object.keys(scn.menuObjs).includes(item.name)){
			let rayMesh = genRaycastMesh(mesh.bb.x, mesh.bb.y);
			rayMesh.bb = mesh.bb; 
			rayMesh.name = item.name;
			rayMesh.add(mesh);
			scn.carousel[item.name] = rayMesh;
			scn.carousel.add(rayMesh);
			scn.carouselRays.push(rayMesh);
			continue;
		}
		if(item.name == "close"){
			let rayMesh = genRaycastMesh(mesh.bb.x, mesh.bb.y);
			rayMesh.bb = mesh.bb;
			rayMesh.name = item.name;
			rayMesh.add(mesh);
			scn[item.name] = rayMesh;
			scn.add(rayMesh);
			continue;
		}
		if(item.name == "brand"){
			mesh.name = item.name;
			scn[item.name] = mesh;
			scn.add(mesh);
		}
	}
	scn.close.visible = false;
	scn.carousel.angle = Math.trunc(( (Math.PI/180 * 360)/scn.carousel.children.length)*100)/100;
	for(let i = 0; i < scn.carousel.children.length; i++){
		scn.carousel.children[i].data = { angle: scn.carousel.angle*i, pX: Math.sin(scn.carousel.angle*i), pY: Math.cos(scn.carousel.angle*i) };
	}
	scn.intersectedObjs = scn.carouselRays;
	delete scn.meshes;
	let htmlElmn = document.getElementsByClassName('invisible')[0];
	htmlElmn.style.opacity = 0;
	htmlElmn.style.display = 'none';
	resize();
	window.addEventListener( 'resize', resize, false );
	window.addEventListener( 'pointermove', pointerMove );
	window.addEventListener( 'pointerdown', pointerDown );
	window.addEventListener( 'wheel', wheel, { passive: false } );
	animate();
}
function openInfo(){
	scn.stat = 'lock';
	scn.camViewSize = calcViewSize(scn.cam, scn.cam[scn.stat].z, 0, 0);
	updateObjs();
	scn.infoC.infoT.w = Math.trunc((scn.camViewSize.x * 0.9) *100)/100;
	scn.infoC.infoT.position.x = -scn.infoC.infoT.w/2;
	scn.infoC.infoT.position.y = (scn.camViewSize.y/2) - (scn.brand.lock.y/3);
	scn.infoC.infoT.visible = true;
	scn.carousel.activeR = Math.PI*2 - scn.carousel.active.data.angle;
	scn.carousel.activeRDelta = scn.carousel.activeR;
	if(Math.abs(scn.carousel.rotation.y - scn.carousel.activeR) >= Math.PI){
		if(scn.carousel.rotation.y > scn.carousel.activeR){
			scn.carousel.activeRDelta += Math.PI*2;
		}else{
			scn.carousel.rotation.y += Math.PI*2;
		}
	}
	scn.carousel.activeRDuration = Math.ceil(Math.abs(scn.carousel.rotation.y - scn.carousel.activeRDelta))/Math.PI;
	for(let i = 0; i < scn.carousel.children.length; i++){
		if(scn.carousel.children[i].data.angle != scn.carousel.active.data.angle){
			scn.carousel.children[i].traverse(function(child){
				animeItem(child, 'material', ['opacity'], [0], 0.7);
			});
		}
	}
	changeColor(scn.carousel.active.children[0], "active");
	animeItem(scn.cam, 'position', ['x', 'y', 'z'], [scn.cam.lock.x, scn.cam.lock.y, scn.cam.lock.z], 0.7);
	animeItem(scn.cam, 'target', ['y'], [scn.cam.lock.target], 0.7);
	animeItem(scn.brand, 'scale', ['x', 'y'], [scn.brand.lock.s, scn.brand.lock.s], 0.7);	
	animeItem(scn.brand, 'position', ['x', 'y'], [scn.brand.lock.x, scn.brand.lock.y], 0.7);
	animeItem(scn.carousel, 'position', ['y'], [scn.carousel.lock.y], 0.7);
	animeItem(scn.carousel, 'rotation', ['y'], [scn.carousel.activeRDelta], scn.carousel.activeRDuration, 0, function() {
		animeItem(scn.carousel.active, 'scale', ['x', 'y'], [scn.carousel.childScale*2.6, scn.carousel.childScale*2.6], 0.7);
		animeItem(scn.infoC.infoT, 'position', ['x'], [0], 0.7);
		animeItem(scn.infoC.infoT, 'scale', ['x'], [scn.infoC.infoT.w], 0.7, 0, function(){
			plotElements( scn.menuObjs[ scn.carousel.active.name ] );
		});
	});
}
function plotElements( content ){
	scn.infoC.infoBlock.w = Math.ceil((scn.infoC.infoT.w * 0.95) *100)/100;
	scn.infoC.infoBlock.padW = Math.round((scn.infoC.infoBlock.w * 0.04) *100)/100;
	scn.infoC.infoBlock.padH = Math.round((scn.infoC.infoBlock.w * 0.05) *100)/100;
	scn.infoC.infoBlock.padMedia = Math.round((scn.infoC.infoBlock.padW/2) *100)/100;
	scn.infoC.h2.fontSize = Math.ceil((scn.infoC.infoBlock.w/18) * 100)/100;
	scn.infoC.p.fontSize = Math.ceil((scn.infoC.infoBlock.w/24) * 100)/100;
	scn.infoC.infoBlock.h = scn.infoC.infoBlock.padH;
	for( let i = 0; i < content.topics.length; i++){
		let topic = content.topics[i];
		let topicBlock = new Group();

		topicBlock.blockHigher = 0;
		topicBlock.cols = -1;
		if( topic.text ){ topicBlock.cols += topic.text.length }
		if( topic.media ){ topicBlock.cols += topic.media.length }
		topicBlock.colsW = scn.infoC.infoBlock.w - (scn.infoC.infoBlock.padW * topicBlock.cols);

		//block text sorted first to reference blockHigher for block media
		if( topic.text ){ setBlockTexts(topicBlock, topic.text); }
		if( topic.media ){ setBlockMedias(topicBlock, topic.media); }
		
		topicBlock.children.sort((a,b) => a.order - b.order);
		for( let j = 0; j < topicBlock.children.length; j++){
			if(j == 0){
				continue;
			}
			topicBlock.children[j].position.x = topicBlock.children[j-1].colW;
		}
		topicBlock.position.x = -(scn.infoC.infoBlock.w/2);
		topicBlock.position.y = -(scn.infoC.infoBlock.h);
		topicBlock.blockHigher += scn.infoC.infoBlock.padH;
		scn.infoC.infoBlock.h += topicBlock.blockHigher;
		scn.infoC.infoBlock.add( topicBlock );
	}
	scn.infoC.infoBlock.position.y = (scn.camViewSize.y/2 - scn.brand.lock.y/3);
	scn.cam.bottomLimit = -Math.trunc( scn.infoC.infoBlock.h - scn.camViewSize.y/2 );
	displayInfo();
}
function setBlockTexts(topicBlock, topicTextsBlocks){
	let block, item;
	for( let j = 0; j < topicTextsBlocks.length; j++){
		block = topicTextsBlocks[j];
		item = new Group();
		item.colW = Math.round(((topicBlock.colsW * block.width)/100) * 100 )/100;
		item.order = parseInt(block.order);
		item.blockHeight = 0;
		for( let k = 0; k < block.data.length; k++){
			let elmnt = block.data[k];
			let wordsArr = elmnt.info;
			let fontSize = scn.infoC[elmnt.tag].fontSize;
			let fontFamily = scn.infoC[elmnt.tag].fontFamily;
			let textBlock = alignTextBlock(wordsArr, item.colW, fontSize);
			let textMesh = generateText(textBlock, fontFamily, fontSize);
			textMesh.position.y = -(item.blockHeight - (textMesh.bb.h/fontSize) ) ;
			item.blockHeight += textMesh.bb.h;
			item.add(textMesh);
		}
		if( topicBlock.blockHigher < item.blockHeight){
			topicBlock.blockHigher = item.blockHeight;
		}
		topicBlock.add( item );
	}
}
function setBlockMedias(topicBlock, topicMedias){
	let block, item, mesh, scalar, posVector, scaleVector, direction, posT;
	for( let j = 0; j < topicMedias.length; j++){
		block = topicMedias[j];
		item = new Group();
		item.colW = Math.round(((topicBlock.colsW * block.width)/100) * 100 )/100;
		item.order = parseInt(block.order);
		posVector = 'x';
		scaleVector = 'w';
		direction = 1;
		posT = 0;
		item.mediasAspect = block.mediasW/block.mediasH;
		if(topicBlock.blockHigher == 0){
			topicBlock.blockHigher = (item.colW/block.data.length)/item.mediasAspect;
		}
		item.colAspect = item.colW/topicBlock.blockHigher;
		if( item.colAspect >= 1){
			scalar = (item.colW - (scn.infoC.infoBlock.padMedia * (block.data.length-1)))/(block.mediasW/block.data.length);
		}
		if( item.colAspect < 1){
			scalar = topicBlock.blockHigher/(block.mediasH/block.data.length);
			posVector = 'y';
			scaleVector = 'h';
			direction = -1;
		}
		for( let k = 0; k < block.data.length; k++){
			let elmnt = block.data[k];
			mesh = scn.loaderClasses[elmnt.tag][1](elmnt.src);
			mesh.scale.setScalar(scalar/block.data.length);
			mesh.position[posVector] = posT;
			posT += (((mesh.bb[scaleVector]/block.data.length)*scalar) + scn.infoC.infoBlock.padMedia) * direction;
			item.add(mesh);
			if(elmnt.href != null){
				let rayMesh = genRaycastMesh(mesh.bb.w, mesh.bb.h);
				rayMesh.name = 'rayLink';
				rayMesh.url = elmnt.href;
				rayMesh.position.set(mesh.bb.w/2, -mesh.bb.h/2, 0);
				mesh.add(rayMesh);
				scn.topicRays.push(rayMesh);
			}
		}
		topicBlock.add( item );
	}
}
function displayInfo(){
	scn.close.visible = true;
	scn.close.scale.setScalar( scn.close[scn.stat].s );
	scn.close.position.y = scn.close.lock.y;
	scn.topicRays.push(scn.close);
	animeItem(scn.infoC.infoT, 'position', ['y'], [ (-(scn.infoC.infoBlock.h/2 - (scn.camViewSize.y/2 - scn.brand.lock.y/3 )) )], 0.7);
	animeItem(scn.infoC.infoT, 'scale', ['y'], [scn.infoC.infoBlock.h], 0.7, 0, function(){
		for(let i = 0; i < scn.infoC.infoBlock.children.length; i++){
			for(let j = 0; j < scn.infoC.infoBlock.children[i].children.length; j++){
				for(let k = 0; k < scn.infoC.infoBlock.children[i].children[j].children.length; k++){
					scn.infoC.infoBlock.children[i].children[j].children[k].traverse(function(child){
						animeItem(child, 'material', ['opacity'], [1], 0.5);
					});
				}
			}
		}
		animeItem(scn.close, 'position', ['x'], [scn.close.lock.x], 0.5, 0);
		window.addEventListener( "keydown", keyDown, false );
	});
}
function closeInfo(){
	updateObjs();
	scn.currIntersect = null;
	window.removeEventListener( "keydown", keyDown);
	scn.renderer.domElement.removeEventListener( "touchStart", touchStart);
	scn.renderer.domElement.removeEventListener( "touchMove", touchMove);
	for(let i = 0; i < scn.infoC.infoBlock.children.length; i++){
		for(let j = 0; j < scn.infoC.infoBlock.children[i].children.length; j++){
			for(let k = 0; k < scn.infoC.infoBlock.children[i].children[j].children.length; k++){
				scn.infoC.infoBlock.children[i].children[j].children[k].traverse(function(child){
					animeItem(child, 'material', ['opacity'], [0], 0.5);
				});
			}
		}
	}
	animeItem(scn.close, 'position', ['x'], [scn.close.mov.x], 0.5, 0, function(){
		animeItem(scn.infoC.infoT, 'position', ['y'], [(scn.camViewSize.y/2 - scn.brand.lock.y/3)], 0.5);
		animeItem(scn.infoC.infoT, 'scale', ['y'], [0.2], 0.5, 0, function(){
			animeItem(scn.infoC.infoT, 'position', ['x'], [-scn.infoC.infoT.w/2], 0.5);
			animeItem(scn.infoC.infoT, 'scale', ['x'],  [0], 0.5, 0, function(){
				scn.close.visible = false;
				scn.infoC.infoBlock.clear();
				hideInfo(scn);
			});
		});
	});
}
function hideInfo(){
	scn.stat = 'mov';
	updateObjs();
	for(let i = 0; i < scn.carousel.children.length; i++){
		if(scn.carousel.children[i].name != scn.carousel.active.name){
			scn.carousel.children[i].traverse(function(child){
				animeItem(child, 'material', ['opacity'], [1], 0.5);
			});
		}
	}
	changeColor(scn.carousel.active.children[0], "normal");
	animeItem(scn.carousel.active, 'scale', ['x', 'y'], [scn.carousel.childScale, scn.carousel.childScale], 0.6);
	animeItem(scn.brand, 'position', ['x', 'y'], [scn.brand.mov.x, scn.brand.mov.y], 0.6);
	animeItem(scn.carousel, 'position', ['y', 'z'], [scn.carousel.mov.y, 0], 0.6);
	animeItem(scn.cam, 'target', ['y'], [scn.cam.mov.target], 0.7);	
	animeItem(scn.cam, 'position', ['x', 'y', 'z'], [scn.cam.mov.x, scn.cam.mov.y, scn.cam.mov.z], 0.6, 0, function(){
		scn.carousel.active = null;
	});
}
function resize(){
	scn.canvas.width = window.innerWidth;
	scn.canvas.height = window.innerHeight;
	scn.renderer.setSize( scn.canvas.width, scn.canvas.height );
	scn.cam.aspect = scn.canvas.clientWidth / scn.canvas.clientHeight;
	scn.cam.updateProjectionMatrix();
	updateObjs();
	scn.brand.scale.setScalar( scn.brand[scn.stat].s );
	scn.brand.position.x = scn.brand[scn.stat].x;
	scn.brand.position.y = scn.brand[scn.stat].y;
	
	scn.close.scale.setScalar( scn.close[scn.stat].s );
	scn.close.position.x = scn.close[scn.stat].x;
	scn.close.position.y = scn.close[scn.stat].y;
	
	scn.carousel.position.y = scn.carousel[scn.stat].y;
	if(scn.stat == 'mov'){
		scn.carousel.radius = clamp( scn.camViewSize.x/3, 3, 16 );
		scn.carousel.childScale = clamp( scn.camViewSize.x/22, 0.2, 2 );
		for(let i = 0; i < scn.carousel.children.length; i++){
			scn.carousel.children[i].position.x = scn.carousel.radius * scn.carousel.children[i].data.pX;
			scn.carousel.children[i].position.z = scn.carousel.radius * scn.carousel.children[i].data.pY;
			scn.carousel.children[i].scale.setScalar( scn.carousel.childScale );
		}
	}
	if(scn.stat == 'lock'){
		scn.carousel.active.children[0].scale.setScalar( scn.close.lock.s );
	}
}
function updateObjs(){
	scn.camViewSize = calcViewSize(scn.cam, scn.cam[scn.stat].z, 0, 0);
	
	scn.brand.mov = { x: 0, y: clamp( scn.camViewSize.x/12, 2, scn.camViewSize.x/10 ), s: clamp( scn.camViewSize.x/72, 0.2, 0.6 ) };
	
	scn.brand.lock = { x: (-scn.camViewSize.x/2 + (scn.brand.bb.x/2) ), y: (scn.camViewSize.y/2 - (scn.brand.bb.x/2) ), s: clamp( scn.camViewSize.x/124, 0.2, 0.6 )}; 
	
	scn.close.mov = { x: (scn.camViewSize.x + (scn.close.bb.x/2)), y: (scn.brand.lock.y), s: clamp( scn.camViewSize.x/72, 0.2, 0.6 )  };
	
	scn.close.lock = { x: -scn.brand.lock.x, y: scn.brand.lock.y, s: clamp( scn.camViewSize.x/72, 0.4, 0.8 ) };

	scn.carousel.mov = { y: -scn.brand.mov.y };
	scn.carousel.lock = { y: scn.camViewSize.y/2  - (scn.brand.bb.y/2)};
}
function pointerDown( event ){
	event.preventDefault();
	scn.pointerDown = true;
	window.removeEventListener( 'pointerdown', pointerDown );
	window.addEventListener( 'pointerup', pointerUp );
	scn.v2.x = ( event.clientX / window.innerWidth ) * 2 - 1;
	scn.v2.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
	scn.initPos = {x: scn.v2.x, y: scn.v2.y} ;
	scn.raycaster.setFromCamera( scn.v2, scn.cam );
	scn.intersects = scn.raycaster.intersectObjects( scn.intersectedObjs, false );
	if ( scn.intersects.length > 0 ) {
		scn.currIntersect = scn.intersects[0].object;
		if(scn.stat == 'mov'){
			scn.carousel.active = scn.currIntersect;
			scn.intersectedObjs = scn.topicRays;
			if(scn.menuObjs[scn.currIntersect.name].loaded == false){
				loadFiles( [ scn.menuObjs[scn.currIntersect.name] ], openInfo );
				return;
			}
			openInfo();
			return;
		}
		if(scn.stat == 'lock'){
			if(scn.currIntersect.name == "close"){
				scn.intersectedObjs = scn.carouselRays;
				closeInfo();
				return; 
			}
			if(scn.currIntersect.name == "rayLink"){
				linkPage(scn.currIntersect.url);
			}
		}
	}
}
function pointerUp( event ){
	event.preventDefault();
	scn.pointerDown = false;
	window.addEventListener( 'pointerdown', pointerDown );
	window.removeEventListener( 'pointerup', pointerUp );
}
function pointerMove( event ) {
	event.preventDefault();
	if(scn.stat == 'mov'){
		scn.v2.x = ( event.clientX / window.innerWidth ) * 2 - 1;
		scn.v2.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
		scn.raycaster.setFromCamera( scn.v2, scn.cam );
		scn.intersects = scn.raycaster.intersectObjects( scn.intersectedObjs, false );
		if ( scn.intersects.length > 0 ) {
			let animeArray = [];
			scn.intersected = scn.intersects[0].object;
			if(scn.currIntersect == null){
				//'new'			
				scn.currIntersect = scn.intersected;
				changeColor(scn.currIntersect.children[0], "hover" );
				animeItem(scn.currIntersect, 'scale', ['x','y'], [scn.carousel.childScale*1.6,scn.carousel.childScale*1.6], 0.5);
			}
			if(scn.intersected.name !== scn.currIntersect.name){
				//'changed'
				changeColor(scn.currIntersect.children[0], "normal");
				animeItem(scn.currIntersect, 'scale', ['x','y'], [scn.carousel.childScale,scn.carousel.childScale], 0.5);
				changeColor(scn.intersected.children[0], "hover");
				animeItem(scn.intersected, 'scale', ['x','y'], [scn.carousel.childScale*1.6,scn.carousel.childScale*1.6], 0.5);
				scn.currIntersect = scn.intersected;			
			}
		}
		if ( scn.intersects.length == 0 ) {
			if(scn.currIntersect != null){
				let animeArray = [];
				changeColor(scn.currIntersect.children[0], "normal");
				animeItem(scn.currIntersect, 'scale', ['x','y'], [scn.carousel.childScale,scn.carousel.childScale], 0.5);
				scn.currIntersect = null;
			}
			if( scn.pointerDown ){
				scn.cam.position.x -= scn.v2.x - scn.initPos.x;
				scn.cam.position.x = clamp(scn.cam.position.x, -20, 20);
				scn.cam.position.y -= scn.v2.y - scn.initPos.y;
				scn.cam.position.y = clamp(scn.cam.position.y, 0, 72);
			}
		}
	}
}
function keyDown( event ){
	if (event.key === "ArrowUp") {
		scroll( -3.4, scn );
	}
	if (event.key === "ArrowDown") {
		scroll( 3.4, scn );
	}
}
function wheel( event ){
	event.preventDefault();
	if(scn.stat == 'mov'){
		event.distance = Math.trunc((event.deltaY/16)*100)/100;
		scn.cam.position.z += event.distance;
		scn.cam.position.z = clamp(scn.cam.position.z, scn.cam.mov.z/1.4, scn.cam.mov.z*1.4);
		return;
	}
	scroll( event.deltaY/20 );
}
function touchStart( event ){
	scn.cam.eventPosY = event.touches[ 0 ].pageY;
}
function touchMove( event ){
	let speed = 0.01;
	let deltaY = -( event.touches[ 0 ].pageY - scn.cam.eventPosY );
	scroll( deltaY * speed, scn );
}
function scroll( scrollV ){
	if( scn.stat == 'lock' ){
		scn.cam.position.y -= scrollV;
		scn.cam.target.y -= scrollV;
		if(scn.cam.position.y >= scn.cam.topLimit ){
			scn.cam.position.y = scn.cam.topLimit;
			scn.cam.target.y = scn.cam.topLimit;
		}
		if(scn.cam.position.y <= scn.cam.bottomLimit ){
			scn.cam.position.y = scn.cam.bottomLimit;
			scn.cam.target.y = scn.cam.bottomLimit;
		}
	}
}
function genRaycastMesh(rayW, rayH){
	const rayGeo = new PlaneGeometry( rayW, rayH );
	const rayMat = new MeshBasicMaterial( {color: "#000000", visible: false, side: FrontSide} );
	const rayMesh = new Mesh( rayGeo, rayMat );
	rayGeo.dispose();
	rayMat.dispose();
	return rayMesh;
}
function generateImg(texture){
	texture.colorSpace = SRGBColorSpace;
	let width = texture.source.data.width;
	let height = texture.source.data.height;
	let geometry = new PlaneGeometry( width, height );
	geometry.computeBoundingBox();
	geometry.translate(width/2, -height/2, 0);
	let material = new MeshBasicMaterial( {map: texture, opacity: 0, transparent: true, fog: false} );
	let mesh = new Mesh( geometry, material );
	geometry.dispose();
	material.dispose();
	texture.dispose();
	mesh.bb = {w:width, h:height}
	mesh.aspect = Math.trunc((width/height)*100)/100;
	mesh.scale.normalize();
	return mesh;
}
function generateVid(data){
	const texture = new VideoTexture( data );
	texture.colorSpace = SRGBColorSpace;
	//let width = data.videoWidth;
	//let height = data.videoHeight;
	let width = data.width;
	let height = data.height;
	let geometry = new PlaneGeometry( width, height );
	geometry.computeBoundingBox();
	geometry.translate(width/2, -height/2, 0);
	let material = new MeshLambertMaterial( {map: texture, opacity: 0, transparent: true, fog: false} );
	let mesh = new Mesh( geometry, material );
	mesh.scale.normalize();
	mesh.bb = {w:width, h:height}
	mesh.aspect = Math.trunc((width/height)*100)/100;
	//mesh.name = "video";
	mesh.vidElement = data;
	mesh.vidElement.play();
	geometry.dispose();
	material.dispose();
	texture.dispose();
	return mesh;
}
function generateSvg(data){
	let width = parseFloat(data.xml.attributes.width.nodeValue);
	let height = parseFloat(data.xml.attributes.height.nodeValue);
	const geo = new PlaneGeometry( width, height );
	geo.computeBoundingBox();
	geo.translate(width/2, -height/2, 0);
	const mat = new MeshBasicMaterial( {color: "#000000", visible: false, side: FrontSide, fog: false} );
	const groupMesh = new Mesh(geo, mat);
	geo.dispose();
	mat.dispose();
	groupMesh.bb = {w:width, h:height};
	groupMesh.aspect = Math.trunc((width/height)*100)/100;
	let renderOrder = 2;
	for ( const path of data.paths ){
		const fillColor = path.userData.style.fill;
		if ( fillColor !== undefined && fillColor !== 'none' ) {
			const material = new MeshPhongMaterial( {
				color: new Color().setStyle( fillColor ),
				opacity: 0,
				transparent: true,
				fog: false,
				side: FrontSide,
				depthWrite: false,
				wireframe: false
			} );
			const shapes = SVGLoader.createShapes( path );
			for ( const shape of shapes ) {
				const geometry = new ShapeGeometry( shape );
				geometry.computeBoundingBox();
				const mesh = new Mesh( geometry, material );
				mesh.scale.y *= -1;
				mesh.renderOrder = renderOrder++;
				groupMesh.add( mesh );
				material.dispose();
				geometry.dispose();
			}
		}
		const strokeColor = path.userData.style.stroke;
		if (strokeColor !== undefined && strokeColor !== 'none' ) {
			const material = new MeshPhongMaterial( {
				color: new Color().setStyle( strokeColor ),
				opacity: 1,
				transparent: true,
				fog: false,
				side: FrontSide,
				depthWrite: false,
				wireframe: false
			} );
			for ( const subPath of path.subPaths ) {
				const geometry = SVGLoader.pointsToStroke( subPath.getPoints(), path.userData.style );
				geometry.computeBoundingBox();
				if ( geometry ) {
					const mesh = new Mesh( geometry, material );
					mesh.scale.y *= -1;
					mesh.renderOrder = renderOrder++;
					groupMesh.add( mesh );
					material.dispose();
					geometry.dispose();
				}
			}
		}
	}
	groupMesh.scale.normalize();
	return groupMesh;
}
function alignTextBlock(wordsArr, colW, fontSize){
	let wordCueX = 0;
	let textLine = "";
	fontSize = Math.ceil((fontSize/2.5)*100)/100; // case of fontSize less than 1
	colW = Math.floor(colW*100)/100;
	let lineChars = Math.floor(colW/fontSize);
	for (let i = 0; i < wordsArr.length; i++){
		if(i == wordsArr.length-1){
			if( wordCueX + 1 + wordsArr[i].length >= lineChars ) {
				textLine += "\n";
			}
			textLine += wordsArr[i];
			return textLine;
		}
		
		if( wordCueX + 1 >= lineChars || wordCueX + 1 + wordsArr[i+1].length > lineChars ) {
			textLine += "\n";
			wordCueX = 0;
			continue;
		}
		if( wordCueX < lineChars ) {
			textLine += wordsArr[i];
			wordCueX += (wordsArr[i].length);
		}
		if( wordCueX + 1 < lineChars ) {
			textLine += " ";
			wordCueX += 1;
		}
	}
}
function generateText(textContent, fontStyle, fontSize){
	let geometry = new TextGeometry( textContent, {
		font: fontStyle,
		size: fontSize,
		height: 0.0,
		depth: 0.0,
		curveSegments: 1,
		bevelEnabled: false,
		bevelThickness: 0,
		bevelSize: 0,
	} );
	geometry.clearGroups();
	geometry.computeBoundingBox();
	geometry.computeVertexNormals();
	
	let textMat = new MeshBasicMaterial( { color: "#04453A", transparent: true, fog: false } );
	let textMesh = new Mesh( geometry, textMat );
	
	textMesh.material.opacity = 0;
	textMesh.scale.normalize();
	let width = Math.trunc( Math.abs(textMesh.geometry.boundingBox.min.x - textMesh.geometry.boundingBox.max.x) *100)/100 ;
	let height = Math.trunc( Math.abs(textMesh.geometry.boundingBox.min.y - textMesh.geometry.boundingBox.max.y) *100)/100 ;
	textMesh.geometry.translate(0, -height, 0);
	textMesh.bb = {w:width, h:height};
	geometry.dispose();
	textMat.dispose();
	return textMesh;
}
function linkPage(url){
	window.open(url); 
}
function calcViewSize(camera, depth, vX, vY){
	return camera.getViewSize(depth, scn.v2.set(vX, vY) );
}
function rotateCarousel(obj, camera){
	if(obj.rotation.y >= Math.PI*2){
		obj.rotation.y = obj.rotation.y - Math.PI*2;
	}
	if(obj.rotation.y < 0){
		obj.rotation.y = obj.rotation.y + Math.PI*2;
	}
	obj.rotation.y -= camera.position.x/500 + 0.002;
}
function setScene(){
	scn.raf = setRAF(30);
	scn.background = new Color( "#ffffff" );
	scn.canvas = document.getElementById("canvas");
	scn.canvas.bb = scn.canvas.getBoundingClientRect();
	scn.canvas.width = Math.trunc(scn.canvas.bb.width*100)/100;
	scn.canvas.height = Math.trunc(scn.canvas.bb.height*100)/100;
	scn.pointerDown = false;
	scn.currIntersect = null;
	scn.pointer = new Vector2();
	scn.raycaster = new Raycaster();
	scn.intersectedObjs = [];
	scn.carouselRays = [];
	scn.topicRays = [];
	scn.renderGroup = [];
	scn.v2 = new Vector2();
	scn.renderer = setRenderer();
	scn.stat = 'mov';
	scn.cam = setCamera();
	scn.camViewSize = calcViewSize(scn.cam, scn.cam[scn.stat].z, 0, 0);
	scn.cam.lights = setLights();
	scn.colors = {
		stroke: { 
			"normal": {r: 0.004, g: 0.042, b: 0.036 },
			"hover": {r: 0.006, g: 0.08, b: 0.06 },
			"active": {r: 0.006, g: 0.08, b: 0.05 }
		},
		fill: {
			"normal": {r: 0.024, g: 0.57, b: 0.41 }, 
			"hover": {r: 0.1, g: 0.72, b: 0.4 },
			"active": {r: 0.1, g: 0.72, b: 0.7 }
		},
		glow: {
			"normal": {r: 0.033, g: 0.830, b: 0.597 }, 
			"hover": {r: 0.5, g: 0.9, b: 0.8},
			"active": {r: 0.9, g: 1.0, b: 0.9 }
		}
	}
	scn.fonts =  {
		rubick: {
			loaded: false, topics: [
				{ media: [{
					data:[
					{ src : 'static/fonts/rubik/Rubik-Regular.ttf', tag: 'ttf' },
					{ src : 'static/fonts/rubik/Rubik-Bold.ttf', tag: 'ttf' } ]}
				]}
			]
		}
	};
	scn.meshes = {
		homepage: {
			 loaded: false, topics: [
				{ media: [{
					data: [
					{ src : 'static/js/webgl/models/homepage/homepage.fbx', tag: 'fbx' } ]}
				]}
			]
		}
	};
	scn.loaderClasses = { fbx: [FBXLoader] , ttf: [TTFLoader], webp: [TextureLoader, generateImg], svg: [SVGLoader, generateSvg], mp4: [VideoTexture, generateVid] };
	return scn;
}
function setRenderer(){
	let renderer = new WebGLRenderer( { canvas:scn.canvas, antialias: true, alpha: false, precision: "highp" } );
	renderer.setSize( scn.canvas.width, scn.canvas.height );
	renderer.setPixelRatio( window.devicePixelRatio );
	renderer.shadowMap.enabled = false;
	//renderer.domElement.style.position = 'absolute';
	//renderer.domElement.style.top = 0;
	renderer.toneMapping = ACESFilmicToneMapping;
	renderer.toneMappingExposure = 1;
	//renderer.autoClear = false;
	return renderer;
}
function setCamera(){
	let cam = new PerspectiveCamera( 50, scn.canvas.width / scn.canvas.height, 10, 200  );
	cam.mov = { x:0, y:24, z:48, target: -2 };
	cam.lock = { x:0, y:0, z:96, target: 0 };
	cam.target = new Vector3(0, cam.mov.target, 0);
	cam.position.set( cam.mov.x, cam.mov.y, cam.mov.z );
	cam.topLimit = 0;
	scn.add( cam );
	return cam;
}
function setLights(){
	let light = new DirectionalLight( 0xFEFEFE, 3 );
	light.position.set( 0, 12, 28 );
	scn.cam.add( light );
	return light;
}
function setCarousel(){
	let carousel = new Group();
	carousel.scale.normalize();
	
	scn.add(carousel);
	return carousel;
}
function setinfoC(){
	let infoC = new Group();
	infoC.position.set(0, 0, 0);
	infoC.h2 = {fontSize: 12, fontFamily: scn.fonts.rubick.topics[0].media[0].data[1].src}
	infoC.p = {fontSize: 6, fontFamily: scn.fonts.rubick.topics[0].media[0].data[0].src}
	
	let infoBlock = new Group();
	infoC.add( infoBlock );
	infoC.infoBlock = infoBlock;
	
	let infoTGeo = new PlaneGeometry( 1, 1 );
	let infoTMat = new MeshPhongMaterial( { color: 0x33EBCB, flatShading: true ,transparent: false, fog: false } );
	let infoT = new Mesh( infoTGeo, infoTMat );
	infoTGeo.dispose();
	infoTMat.dispose();
	let infoTEdge = new EdgesGeometry(infoTGeo.geometry);
	let infoTEdgeMat = new MeshPhongMaterial( { color: 0x0E3F36, flatShading: true ,transparent: false, fog: false } );
	let infoTEdgeLine = new LineSegments(infoTEdge, infoTEdgeMat ); 
	infoTEdge.dispose();
	infoTEdgeMat.dispose();
	infoT.add( infoTEdgeLine );
	infoC.add( infoT );
	infoC.infoT = infoT;
	infoT.geometry.computeBoundingBox();
	infoT.scale.normalize();
	infoT.renderOrder = 0;
	infoT.scale.y = 0.2;
	//infoT.position.set(0, 0, -0.01);								
	infoT.visible = false;
	scn.add( infoC );
	return infoC;
}
function changeColor(obj, mode){
	obj.traverse(function(child){
		animeItem(child.material, 'color', ['r', 'g', 'b'], [ scn.colors[child.name][mode].r, scn.colors[child.name][mode].g, scn.colors[child.name][mode].b], 0.5);
	});
}
function clamp(val, min, max) {
    return Math.trunc( (val > max ? max : val < min ? min : val) * 100) / 100;
}
function animeItem(item, property, paramArr, endVArr, duration, delay=0, endAction=null, ease=easeInOutQuad){
	duration = Math.trunc(((duration + delay) * 1000)/scn.raf.fps);
	for (let i = 0; i < paramArr.length; i++){
		let startV = item[property][paramArr[i]];
		let deltaV = endVArr[i] - startV;
		if(i > 0){endAction = null}
		scn.renderGroup.push( [ scn.raf.currFrame, duration, item, property, [paramArr[i]], ease, startV, deltaV, endVArr[i], endAction ] );
	}
	return;
}
function animate() {
	scn.raf.fpsInterval = scn.raf.currT - scn.raf.prevT;
	if(scn.raf.fpsInterval >= scn.raf.fpsD){
		scn.raf.prevT = scn.raf.currT;
		render();
	}
	scn.raf.currT += scn.raf.fps;
	
	requestAnimationFrame(animate);
}
function render(){
	scn.cam.lookAt(scn.cam.target);
	if(scn.stat == 'mov'){ rotateCarousel( scn.carousel, scn.cam ); }
	for (let i = 0; i < scn.carousel.children.length; i++){
		scn.carousel.children[i].lookAt( scn.cam.position );
	}
	for(let i = 0; i < scn.renderGroup.length; i++){
		// [ startFrame, duration(seconds), item, property, param, ease, startV, deltaV, endV, endAction ]
		scn.raf.motionCount = scn.raf.currFrame - scn.renderGroup[i][0];
		if(scn.raf.motionCount >= scn.renderGroup[i][1]){
			scn.renderGroup[i][2][scn.renderGroup[i][3] ][scn.renderGroup[i][4] ] = scn.renderGroup[i][8];
			if(scn.renderGroup[i][9]){
				scn.renderGroup[i][9]();
			}
			scn.renderGroup.splice(i, 1);
			continue;
		}
		scn.renderGroup[i][2][scn.renderGroup[i][3] ][scn.renderGroup[i][4] ] = Math.trunc(scn.renderGroup[i][5](scn.raf.motionCount, scn.renderGroup[i][6], scn.renderGroup[i][7], scn.renderGroup[i][1])*100 )/100;			
	}
	scn.raf.currFrame++;
	scn.cam.updateProjectionMatrix();
	scn.renderer.render( scn, scn.cam );
}
function setRAF(fps){
	return { fps: fps, fpsD: Math.round( 1000/fps ), currFrame: 0, currT: 0, prevT: 0, fpsInterval: 0, motionCount: 0}
}
function easeInOutQuad(t, b, c, d) {
	if ((t /= d / 2) < 1) return c / 2 * t * t + b;
	return -c / 2 * ((--t) * (t - 2) - 1) + b;
}
init();
</script>
</body>
</html>
