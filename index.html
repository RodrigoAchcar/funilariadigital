<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes, minimum-scale=1.0, maximum-scale=5.0">		
	<title>Funilaria Digital</title>
	<meta name="author" content="funilariadigital">
	<link rel="apple-touch-icon" sizes="180x180" href="./media/icon/favicon/apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="./media/icon/favicon/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="./media/icon/favicon/favicon-16x16.png">
	<link rel="manifest" href="./media/icon/favicon/site.webmanifest">
	<style>
        html, body, #content { width: 100%; height:100%; min-height:100%; overflow: hidden;}
        * {padding: 0; margin: 0;}
        .invisible{ opacity: 1; display: none; }
        h1, h2, p{ color: #ffffff; }
        canvas{ width: 100%; height: 100%; 	object-fit: contain; }	
	</style>
</head>
<body>
<canvas id="canvas"></canvas>
<div id="container" class="invisible">
	<div id="3d" class="contentBlock">
		<div class="topicBlock">
			<div data-width="100" data-order="0" data-type="media">
				<a href="https://funilariadigital.com.br/art-gallery-display/" target="_blank" >
					<noscript>
					<video title="Art Gallery Display" muted loop>
						<source src="./media/site/videos/Art-Gallery-Display-mobile.mp4" type="video/mp4">
					</video>
					</noscript>
				</a>
				<a href="https://funilariadigital.com.br/open-map-scenario/" target="_blank" >
					<noscript>
					<video title="3D open map scenario" muted loop>
					<source src="./media/site/videos/Open-Map-Scenario-mobile.mp4" type="video/mp4">
					</video>
					</noscript>
				</a>
			</div>
		</div>
		<div class="topicBlock">
			<div data-width="100" data-order="0" data-type="text">
				<h2>Interactive 3D Projects</h2>
				<p>Pipeline align, Webgl mesh refactor. Transpile heavy rendered projects to real time, all available platforms. Fallbacks for a robust build.</p>
			</div>
		</div>
		<div class="topicBlock">
			<div data-width="60 "data-order="0" data-type="text">
				<h2>Clients and Workforce Visualized</h2>
				<p>Enhance daily tasks, sales presentation, point-of-sale display, team briefing. Easy to use resources at hand.</p>
			</div>
			<div data-width="40" data-order="1" data-type="media">
			<a href="https://funilariadigital.com.br/object-3d-menu/" target="_blank" >
				<noscript>
				<img src="./media/site/pictures/interactive-brain-shaped-menu-mobile.avif" alt="Mesh Shape Menu" />
				</noscript>
			</a>
			<a href="https://funilariadigital.com.br/character-interactivity/" target="_blank" >
			<noscript>
			<img src="./media/site/pictures/character-rigging-mobile.avif" alt="Rigging Setup Character" />
			</noscript>
			</a>
			</div>
		</div>
		<div class="topicBlock">
			<div data-width="40" data-order="0" data-type="text">
				<h2>Graphic Layer Only</h2>
				<p>Dynamic or static display done with regular HTML/XML inputs. Preview integrity preserved on improvement updates.</p>
			</div>
			<div data-width="60" data-order="1" data-type="text">
				<h2>Product Immersion by Refresh Rate</h2>
				<p>3D available for market strategies and business tools. A medium to provide consumers be part of what they are interested.</p>
			</div>
		</div>
		<div class="topicBlock">
			<div data-width="100" data-order="0" data-type="media">
				<a href="https://funilariadigital.com.br/planetarium/" target="_blank" >
				<noscript>
				<img src="./media/site/pictures/planetarium-mobile.avif" alt="solar-system-model-3d" />
				</noscript>
				</a>
			</div>
		</div>
	</div>
	<div id="ux" class="contentBlock">
		<div class="topicBlock">
			<div data-width="100" data-order="0" data-type="text">
				<h2>Any Screen Size Responsive</h2>
				<p>Fast layout adjust, dynamic information formatted on the fly. Render the exact resolution to each user. Ideal experience for humans and robots.</p>
			</div>
		</div>
		<div class="topicBlock">
			<div data-width="60" data-order="1" data-type="text">
				<h2>Customized Templates on Demmand</h2>
				<p>Convenient user access on what matters. Unique shapes and widgets made for every job. Original medias presented to the audience.</p>
			</div>
			<div data-width="40" data-order="0" data-type="media">
				<noscript>
				<img src="./media/site/pictures/interactive-layout-preview-daylight-mobile.avif" alt="Business makeover viewer day" />
				</noscript>
				<noscript>
				<img src="./media/site/pictures/interactive-layout-preview-afternoon-mobile.avif" alt="Business makeover viewer afternoon" />
				</noscript>
				<noscript>
				<img src="./media/site/pictures/interactive-layout-preview-night-mobile.avif" alt="Business makeover viewer night" />
				</noscript>
			</div>
		</div>
		<div class="topicBlock">
			<div data-width="50" data-order="0" data-type="text">
				<h2>Logic Over Third Parties</h2>
				<p>Strict native script features. Vanilla JS, HTML and CSS. Less libraries overhead or multi featured addons. Know whats happening in all lines.</p>
			</div>
			<div data-width="50" data-order="1" data-type="text">
				<h2>Useful Responsive Layouts</h2>
				<p>Improve feedback insights by an easy to see interface. Figure which strategies are doing positive results and what needs update.</p>
			</div>
		</div>
		<div class="topicBlock">
			<div data-width="100" data-order="0" data-type="media">
				<noscript>
				<img src="./media/site/vectors/javascript-logo.svg" alt="javascript-logo" />
				</noscript>
				<noscript>
				<img src="./media/site/vectors/webgl-logo.svg" alt="webgl-logo" />
				</noscript>
				<noscript>
				<img src="./media/site/vectors/python-logo.svg" alt="python-logo" />
				</noscript>
				<noscript>
				<img src="./media/site/vectors/css3-logo.svg"  alt="css3-logo" />
				</noscript>
			</div>
		</div>
	</div>
	<div id="img" class="contentBlock">
		<div class="topicBlock">
			<div data-width="100" data-order="0" data-type="media">
				<noscript>
				<video title="Sun Timelapse" muted loop>
					<source src="./media/site/videos/sun-timelapse-mobile.mp4" type="video/mp4">
				</video>
				</noscript>
				<noscript>
				<video title="Drone Aerial Footage" muted loop>
					<source src="./media/site/videos/drone-florianopolis-beiramar-mobile.mp4" type="video/mp4">
				</video>
				</noscript>
			</div>
		</div>
		<div class="topicBlock">
			<div data-width="40" data-order="0" data-type="text">
				<h2>Media Output Profiles Render</h2>
				<p>Quality files processed for screen sizes. Fast loading time, color fidelity, smooth organic shapes, fluid animations.</p>
			</div>
			<div data-width="50" data-order="1" data-type="text">
				<h2>Audience Range Achieved Through Performance</h2>
				<p>Up to date format standards display art and documents at the right medium. Correct measures means less bounces, positive user experience.</p>
			</div>
		</div>
		<div class="topicBlock">
			<div data-width="100" data-order="0" data-type="media">
				<noscript>
				<img src="./media/site/pictures/rodrigo-dias-painting-shirt-mobile.avif" alt="Rodrigo Dias Ink on Fabric Art" />
				</noscript>
			</div>
		</div>
		
		<div class="topicBlock">
			<div data-width="50" data-order="0" data-type="text">
				<h2>Better Ranks with Best Practices</h2>
				<p>Search engines, social media alghoritms, web analytics prevails fit medias. A lean payload saves time, agregate crawlers priority points.</p>
			</div>
			<div data-width="50" data-order="1" data-type="text">
				<h2>Indexed Media Versions Routine</h2>
				<p>Batch process versatile formats by devices required. Aspect ratio, connection bandwidth, bit rates carefuly revised for publishing.</p>
			</div>
		</div>
		<div class="topicBlock">
			<div data-width="100" data-order="0" data-type="media">
				<noscript>
				<img src="./media/site/pictures/orthophoto-utfpr-campus-downtown-mobile.avif" alt="Orthomosaic georeferenced composition" />
				</noscript>
			</div>
		</div>
	</div>
	<div id="seo" class="contentBlock">
		<div class="topicBlock">
			<div data-width="100" data-order="0" data-type="text">
				<h2>Profit From Relevant Insights</h2>
				<p>Automate apps to monitor business activities. Specialized tools capable to feed, manipulate, rearrange it's parameters, narrow objectives.</p>
			</div>
		</div>
		<div class="topicBlock">
			<div data-width="100" data-order="0" data-type="media">
				<noscript>
				<img src="./media/site/vectors/engagement-statistic-analysis.svg" alt="engagement statistic analysis" />
				</noscript>
			</div>
		</div>
		<div class="topicBlock">
			<div data-width="50" data-order="0" data-type="text">
				<h2>Efficient Data Classify</h2>
				<p>Gather massive sorted data. Intuitive easy to feed, clear to visualize. Strategies built from current feedbacks.</p>
			</div>
			<div data-width="50" data-order="1" data-type="text">
				<h2>Wise Planning Approach</h2>
				<p>Measure consumer engagement by an one to many app. Tools to monitor whats new, what is still providing results and what should be replaced.</p>
			</div>
		</div>
		<div class="topicBlock">
			<div data-width="100" data-order="0" data-type="media">
				<noscript>
				<img src="./media/site/vectors/consumer-audience-monitoring.svg" alt="consumer audience monitoring" />
				</noscript>
			</div>
		</div>
		<div class="topicBlock">
			<div data-width="100" data-order="0" data-type="text">
				<h2>Reviews Awareness</h2>
				<p>Audience monitoring automations. Official available data cross referenced on different sources. Search rank valuable method.</p>
			</div>
		</div>
	</div>
	<div id="api" class="contentBlock">
		<div class="topicBlock">
			<div data-width="100" data-order="0" data-type="text">
				<h2>Integrate Existent Interface Apps</h2>
				<p>Sales, workflow, optimization of any kind to enhance relations. New data sources from respected reputation service providers.</p>
			</div>
		</div>
		<div class="topicBlock">
			<div data-width="100" data-order="0" data-type="media">
				<noscript>
				<img src="./media/site/vectors/workflow-convenience.svg" alt="workflow convenience" />
				</noscript>
			</div>
		</div>
		<div class="topicBlock">
			<div data-width="50" data-order="0" data-type="text">
				<h2>Tools You Already Work</h2>
				<p>Most Saas providers offers a complete interface usage. Onboard internal presets with custom tools available. Accessed by latest security procedures.</p>
			</div>
			<div data-width="50" data-order="1" data-type="text">
				<h2>Multiple Sources Data Feed</h2>
				<p>Bundles mounted at the business desired specs. With buit in cross provider hooks, officialy registered. Live, safe, legal.</p>
			</div>
		</div>
		<div class="topicBlock">
			<div data-width="100" data-order="0" data-type="media">
				<noscript>
				<img src="./media/site/vectors/application-cross-reference.svg" alt="application cross reference" />
				</noscript>
			</div>
		</div>
		<div class="topicBlock">
			<div data-width="42" data-order="1" data-type="text">
				<h2>Unified Social Media Manage</h2>
				<p>Media brands have APIs allowed to interact. Social medias, websites, analytics, apps, converged to one assistance asset.</p>
			</div>

			<div data-width="30" data-order="0" data-type="media">
				<noscript>
				<img src="./media/site/vectors/social-media-integrate.svg" alt="social media integrate" />
				</noscript>
			</div>
		</div>
	</div>
	<div id="info" class="contentBlock">
		<div class="topicBlock">
			<div data-width="100" data-order="0" data-type="media">
				<noscript>
				<img src="./media/site/pictures/about-rodrigo-achcar-mobile.avif" alt="about Rodrigo Achcar" />
				</noscript>
			</div>
		</div>
		<div class="topicBlock">
			<div data-width="100" data-order="0" data-type="text">
				<h2>Rodrigo Rodrigues Achcar</h2>
				<p>3D Specialist (Autodesk Maya, DRC SÃ£o Paulo). Mesh set up for animation, rigging, is my thing. As time went by got media production and coding jobs, service auctions disputes.</p>
				<p>Such jobs opportunities provided skills on media post-production, rendering, batch documents and medias reprocess, interactive resources, 2D and 3D animation styles, aerial captures, geopositioned orthomosaic maps.</p>
				<p>Since some time was required monitoring auction posts, I've begin to code automations to feed, sort by interest, database input and content views.</p>
				<p>After that I went for ECMA scripts and focus on graphic layer coding jobs. Medias, UX, WebGL, APIs, SEOs.</p>
			</div>
		</div>
		<div class="topicBlock">
			<div data-width="100" data-order="0" data-type="media">
				<a href="https://www.linkedin.com/in/rodrigo-achcar/" target="_blank" >
				<noscript>
				<img src="./media/site/vectors/linkedin-rodrigo-achcar.svg" alt="linkedin-rodrigo-achcar" />
				</noscript>
				</a>
				<a href="https://github.com/RodrigoAchcar" target="_blank" >
				<noscript>
				<img src="./media/site/vectors/github-rodrigo-achcar.svg" alt="github-rodrigo-achcar" />
				</noscript>
				</a>
				<a href="https://wa.me/5561992720142" >
				<noscript>
				<img src="./media/site/vectors/whatsapp-phone-rodrigo-achcar.svg" alt="whatsapp-phone-rodrigo-achcar" />
				</noscript>
				</a>
				<a href="https://www.facebook.com/rodrigo.achcar.9/" target="_blank" >
				<noscript>
				<img src="./media/site/vectors/facebook-rodrigo-achcar.svg" alt="facebook-rodrigo-achcar" />
				</noscript>
				</a>
				<a href="https://www.instagram.com/rodrigorachcar/" target="_blank" >
				<noscript>
				<img src="./media/site/vectors/instagram-rodrigo-achcar.svg" alt="instagram-rodrigo-achcar" />
				</noscript>
				</a>
				<a href="mailto:rodrigor.achcar@gmail.com" target="_blank" >
				<noscript>
				<img src="./media/site/vectors/email-contact.svg" alt="email-contact" />
				</noscript>
				</a>
			</div>
		</div>
	</div>
</div>
<script type="importmap">
	{
		"imports": {
			"three": "./static/js/webgl/build/three.module.js",
			"three/addons/": "./static/js/webgl/jsm/"
		}
	}
</script>
<script type="module">
import { Cache, WebGLRenderer, ACESFilmicToneMapping, Color, SRGBColorSpace, Vector2, Vector3, Object3D, Scene, PerspectiveCamera, DirectionalLight, Group, Raycaster, LoadingManager, TextureLoader, Texture, VideoTexture, Mesh, MeshStandardMaterial, MeshBasicMaterial, MeshLambertMaterial, MeshPhongMaterial, PlaneGeometry, ShapeGeometry, EdgesGeometry, LineSegments, FrontSide, LineBasicMaterial } from 'three';
import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';	
import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
import { Font } from 'three/addons/loaders/FontLoader.js';
import { TTFLoader } from 'three/addons/loaders/TTFLoader.js';
import { SVGLoader } from 'three/addons/loaders/SVGLoader.js';
Cache.enabled = true;
const scn = new Scene();
const requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;
const cancelAnimationFrame = window.cancelAnimationFrame || window.mozCancelAnimationFrame;
function init(){
	scn.fileObjs = fileObjsLoad();
	scn.filePaths = filePathsLoad();
	scn.menuInfo = {};
	scn.loaderClasses = { fbx: [FBXLoader] , ttf: [TTFLoader], avif: [TextureLoader, generateImg], svg: [SVGLoader, generateSvg], mp4: [VideoTexture, generateVid] };
	updateMediaUrls(scn.filePaths)
	loadFiles( scn.fileObjs, clearFirstLoad);
}
function fileObjsLoad(){
	return {
		fonts: {
			media: [
				{ data: [ {src: '/static/fonts/rubik/Rubik-Regular.ttf', tag: 'ttf', name:'Rubik-Regular'}, {src:'/static/fonts/rubik/Rubik-Bold.ttf', tag: 'ttf', name:'Rubik-Bold' } ] }, 
			]
		},
		models: {
			media: [
				{ data: [ {src: '/static/js/webgl/models/homepage/homepage.fbx', tag: 'fbx', name:'homepage' } ]},
			]
		}
	}
}
function filePathsLoad(){
	const obj = {};
	const content = document.getElementById("container");
	for(let i = 0; i < content.children.length; i++){
		let menuItem = content.children[i];
		let itemID = menuItem.getAttribute("id");
		obj[itemID] = [];
		for(let j = 0; j < menuItem.children.length; j++){
			let topics = menuItem.children[j];
			let topicObj = { media: [], text: [] };
			for(let k = 0; k < topics.children.length; k++){
				let block = topics.children[k];
				let blockObj = { type: block.getAttribute("data-type"), order: block.getAttribute("data-order"), width: block.getAttribute("data-width"), data: [] };
				for(let l = 0; l < block.children.length; l++){
					let elm = block.children[l];
					if( blockObj.type == 'text'){
						blockObj.data.push( { tag: elm.localName, info: elm.innerHTML.split(' ')} );
					}
					if( blockObj.type == 'media'){
						let dataObj = {};
						if(elm.localName == 'a'){
							dataObj.href = elm.getAttribute("href");
							elm = elm.children[0];
						}
						dataObj.src = elm.firstChild.textContent.match( /src="([^\"]+)/ )[1];
						dataObj.tag = dataObj.src.match( /(.+)\.(.+)$/ )[2];
						if(dataObj.tag == 'mp4'){
							const fragment = document.createRange().createContextualFragment(elm.firstChild.textContent).children[0];
							dataObj.src = fragment;
						}
						blockObj.data.push( dataObj );
					}
				}
				topicObj[blockObj.type].push(blockObj);
			}
			if(topicObj.media.length === 0){ delete topicObj.media}
			if(topicObj.text.length === 0){ delete topicObj.text}
			obj[itemID].push(topicObj);
		}
	}
	return obj;
}
function updateMediaUrls(filePathsObj){
	let list = [];
	let regexp = /src\s*=\s*"(.+?)"/g;
	let canvas = window.innerWidth;
	let sizePath = 'mobile'
	if(canvas > 480){ sizePath = 'pc'; }
	if(canvas > 1080){ sizePath = 'tv'; }
	for(let [k,v] of Object.entries(filePathsObj) ){
		for(let i = 0; i<v.length; i++){
			if( v[i].media ){
				for(let j = 0; j<v[i].media[0].data.length; j++){
					if(v[i].media[0].data[j].tag === 'avif'){
						let path = v[i].media[0].data[j].src.replace(/mobile/i, sizePath);
						v[i].media[0].data[j].src = path;
					}
					if(v[i].media[0].data[j].tag === 'mp4'){
						let path = v[i].media[0].data[j].src.firstElementChild.src.replace(/mobile/i, sizePath);
						v[i].media[0].data[j].src.setAttribute('src', path);
						v[i].media[0].data[j].src.load();
					}
				}
			}
		}
	}
	return list;
}
async function loadFiles( filesObj, endAction=null ){
	const manager = new LoadingManager();
	let filesLoadQtd = 0;
	let loadCount = 0;
	for(let types of Object.entries(filesObj) ){
		if(types[1].media){
			for(let i = 0; i < types[1].media.length; i++){
				for(let j = 0; j < types[1].media[i].data.length; j++){
					if(types[1].media[i].data[j].tag !== 'mp4'){
						filesLoadQtd++;
					}
				}
			}
		}
	}
	for(let types of Object.entries(filesObj) ){

		if(types[1].media){
			for(let i = 0; i < types[1].media.length; i++){
				for(let j = 0; j < types[1].media[i].data.length; j++){
					if(types[1].media[i].data[j].tag !== 'mp4'){
						const data = await loadFile(scn.loaderClasses[types[1].media[i].data[j].tag][0], `${types[1].media[i].data[j].src}`);
						if(types[1].media[i].data[j].tag === 'avif'){
							data.colorSpace = SRGBColorSpace;
							types[1].media[i].data[j].width = data.source.data.width;
							types[1].media[i].data[j].height = data.source.data.height;
						}
						if(types[1].media[i].data[j].tag === 'svg'){
							data.colorSpace = SRGBColorSpace;
							types[1].media[i].data[j].width = parseFloat(data.xml.attributes.width.nodeValue);
							types[1].media[i].data[j].height = parseFloat(data.xml.attributes.height.nodeValue);
						}
						types[1].media[i].data[j].src = data;
						if( types[1].media[i].data[j].tag === 'ttf' ){
							types[1].media[i].data[j].src = new Font( data );
						}
						loadCount++;
					}
					if(types[1].media[i].data[j].tag === 'mp4'){
						types[1].media[i].data[j].width = types[1].media[i].data[j].src.videoWidth;
						types[1].media[i].data[j].height = types[1].media[i].data[j].src.videoHeight;
					}
				}
			}
		}
		
	}
	if(loadCount === filesLoadQtd){
		//console.log('loading complete');
		endAction();
	}
	manager.onStart = function () {};
	manager.onProgress = function () {};
	manager.onLoad = function () {};
	manager.onError = function () {};
}
function clearFirstLoad(){
	scn.fonts = {};
	scn.models = {};
	for(let [k, v] of Object.entries(scn.fileObjs) ){
		for(let i = 0; i < v.media[0].data.length; i++){	
			scn[k][v.media[0].data[i].name] = v.media[0].data[i].src;
		}
	}
	dispose(scn.fileObjs.models.media[0].data[0].src);
	delete scn.fileObjs;
	setScene();
}
function setScene(){
	scn.fps = 30;
	scn.fpsD = Math.trunc((1000/scn.fps)*100)/100;
	scn.currFrame = 0;
	scn.motionCount = 0;
	scn.then = performance.now();
	scn.now = performance.now();
	scn.background = new Color( 0xffffff );
	scn.canvas = document.getElementById("canvas");
	scn.canvas.w = window.innerWidth;
	scn.canvas.h = window.innerHeight;
	scn.canvas.deltaW = 0;
	scn.canvas.deltaH = 0;
	scn.pointerDown = false;
	scn.currIntrsc = null;
	scn.pointer = new Vector2();
	scn.raycaster = new Raycaster();
	scn.renderGroup = [];
	scn.initPos = new Vector2();
	scn.renderer = setRenderer();
	scn.attach( setCamera() );
	scn.colors = {
		stroke: { 
			"normal": {r: 0.004, g: 0.042, b: 0.036 },
			"hover": {r: 0.006, g: 0.08, b: 0.06 },
			"active": {r: 0.006, g: 0.08, b: 0.05 }
		},
		fill: {
			"normal": {r: 0.024, g: 0.57, b: 0.41 }, 
			"hover": {r: 0.1, g: 0.72, b: 0.4 },
			"active": {r: 0.1, g: 0.72, b: 0.7 }
		},
		glow: {
			"normal": {r: 0.033, g: 0.830, b: 0.597 }, 
			"hover": {r: 0.5, g: 0.9, b: 0.8},
			"active": {r: 0.9, g: 1.0, b: 0.9 }
		}
	}
	buildScenario();
}
function buildScenario(){
	scn.attach(setCarousel());
	scn.attach(setinfoC());
	let infoBtns = new Group();
	infoBtns.name = 'infoBtns';
	scn.attach(infoBtns);
	let models = scn.models.homepage.children;
	for(let i=0; i< models.length; i++ ){
		let geo = models[i].geometry;
		let strokeMat = new MeshStandardMaterial( { color: new Color('#0E3F36'), fog: false, toneMapped: false, transparent: true, depthWrite : false } );
		let mesh = new Mesh(geo, strokeMat);
		mesh.scale.normalize();
		mesh.geometry.computeBoundingBox();
		mesh.geometry.computeBoundingSphere();
		mesh.bb = {x: Math.abs(mesh.geometry.boundingBox.min.x - mesh.geometry.boundingBox.max.x), y: Math.abs(mesh.geometry.boundingBox.min.y - mesh.geometry.boundingBox.max.y)}; 
		mesh.name = 'stroke';
		geo.dispose();
		strokeMat.dispose();
		if(models[i].children.length > 0){
			let geoFill = models[i].children[0].geometry;
			let fillMat =  new MeshStandardMaterial( { color: new Color('#2BC7AC'), roughness: 1, metalness: 0, fog: false, toneMapped: false, transparent: true, depthWrite : false } );
			let meshFill = new Mesh(geoFill, fillMat);
			meshFill.scale.normalize();
			meshFill.geometry.computeBoundingBox();
			meshFill.geometry.computeBoundingSphere();
			meshFill.name = 'fill';
			geoFill.dispose();
			fillMat.dispose();
			if(models[i].children[0].children.length > 0){
				let geoGlow = models[i].children[0].children[0].geometry;
				let glowMat = new MeshStandardMaterial( { color: new Color('#33EBCB'), roughness: 1, metalness: 0, fog: false, toneMapped: false, transparent: true, depthWrite : false } );
				let meshGlow = new Mesh(geoGlow, glowMat);
				meshGlow.scale.normalize();
				meshGlow.geometry.computeBoundingBox();
				meshGlow.geometry.computeBoundingSphere();
				meshGlow.name = 'glow';
				geoGlow.dispose();
				glowMat.dispose();
				meshFill.attach(meshGlow);
			}
			mesh.attach(meshFill);
		}
		if(Object.keys(scn.filePaths).includes(models[i].name)){
			let rayMesh = genRaycastMesh(mesh.bb.x, mesh.bb.y);
			rayMesh.scale.normalize();
			rayMesh.bb = mesh.bb; 
			rayMesh.name = models[i].name;
			rayMesh.attach(mesh);
			getMesh('menu').attach(rayMesh);
			continue;
		}
		if(models[i].name === "close"){
			let rayMesh = genRaycastMesh(mesh.bb.x, mesh.bb.y);
			rayMesh.scale.normalize();
			rayMesh.bb = mesh.bb;
			rayMesh.name = models[i].name;
			rayMesh.attach(mesh);
			//scn.attach(rayMesh);
			getMesh('infoBtns').attach(rayMesh);
			rayMesh.visible = false;
			continue;
		}
		if(models[i].name == "brand"){
			mesh.name = models[i].name;
			scn.attach(mesh);
		}
	}
	dispose(scn.models.homepage);
	delete scn.models;
	setup();
	getMesh('menu').angle = Math.round(( (Math.PI/180 * 360)/getMesh('menu').children.length)*10)/10;
	for(let i = 0; i < getMesh('menu').children.length; i++){
		getMesh('menu').children[i].data = { angle: getMesh('menu').angle*i, pX: Math.sin(getMesh('menu').angle*i), pY: Math.cos(getMesh('menu').angle*i) };		
	}
	getMesh('menu').r = getMesh('menu').children.length*2;
	for(let i = 0; i < getMesh('menu').children.length; i++){
		getMesh('menu').children[i].position.x = getMesh('menu').r * getMesh('menu').children[i].data.pX;
		getMesh('menu').children[i].position.z = getMesh('menu').r * getMesh('menu').children[i].data.pY;
	}
	window.addEventListener( 'resize', resize, false );
	scn.canvas.addEventListener( 'pointermove', pointermove );
	scn.canvas.addEventListener( 'pointerdown', pointerdown );
	window.addEventListener( 'pointerup', pointerup );
	scn.canvas.addEventListener( 'touchstart', touchstart );
	scn.canvas.addEventListener( 'touchmove', touchmove );
	scn.canvas.addEventListener( 'touchend', touchend );
	scn.canvas.addEventListener( 'wheel', wheel );

	scn.stat = 'mov';
	
	getMesh('cam').position.set(0, Math.ceil(-getMesh('brand').bb.y*0.2), Math.ceil(getMesh('brand').bb.y*2) );
	getMesh('cam').target.y = Math.ceil(-getMesh('brand').bb.y*1.2);
	getMesh('brand').position.set(0, Math.ceil(-getMesh('brand').bb.y), 0);
	getMesh('menu').position.y = Math.ceil(-getMesh('brand').bb.y)*1.4;
	resize();
	animate();
}
function setup(){
	scn.v = {
		mov: {
			camP: [0, Math.ceil(-getMesh('brand').bb.y*0.2), Math.ceil(getMesh('brand').bb.y*4)],
			tP: Math.ceil(-getMesh('brand').bb.y*1.2),
			brandP: [0, Math.ceil(-getMesh('brand').bb.y), 0],
		},
		scroll:{
			camP: Math.floor(getMesh('brand').bb.y*4),
			brandP: [Math.ceil(getMesh('brand').bb.x/2), Math.floor(-getMesh('brand').bb.y), 0]
		}
	}
	scn.states = {
		mov: ( function(){
			rotateCarousel( getMesh('menu'), getMesh('cam') );
			getMesh('cam').position.x = clamp(getMesh('cam').position.x, -20, 20);
			getMesh('cam').position.y = clamp(getMesh('cam').position.y, -30, 0);			
			getMesh('cam').position.z = clamp(getMesh('cam').position.z, 40, 70);
		} ),
		scroll: (
			function(){
			getMesh('cam').position.y = clamp(getMesh('cam').position.y, getMesh('cam').bottomLimit, getMesh('cam').topLimit);
			getMesh('close', ['infoBtns']).position.y = ( (getMesh('cam').position.y) - (getMesh('cam').topLimit) ) + Math.ceil(getMesh('brand').bb.y/2);
			getMesh('cam').target.y = getMesh('cam').position.y;
			getMesh('lightTarget').position.y = getMesh('cam').position.y/2;
		}),
		locked: (function(){})
	};	
}
function resize(){
	scn.renderer.setSize( scn.canvas.parentElement.clientWidth, scn.canvas.parentElement.clientHeight );
	getMesh('cam').aspect = scn.canvas.offsetWidth/ scn.canvas.offsetHeight;
	getMesh('cam').updateProjectionMatrix();
	getMesh('cam').view = calcViewSize( Math.ceil(scn.v.scroll.camP), getMesh('cam').view);
	getMesh('cam').topLimit = Math.ceil(-getMesh('cam').view.y/2);
	let v;
	if(scn.stat === 'mov'){
		v = clamp(Math.floor(getMesh('cam').position.z/getMesh('cam').aspect), 40, 70);
		animeItem(getMesh('cam'), 'position', ['z'], [v], 0.3);
	}
	if(scn.stat === 'scroll'){
		v = clamp( (Math.ceil(scn.v.scroll.camP)*getMesh('cam').aspect), 40, 80);
		animeItem(getMesh('cam'), 'position', ['z'], [v], 0.3);
		if(getMesh('cam').position.y < getMesh('cam').topLimit){
			animeItem(getMesh('cam'), 'position', ['y'], [getMesh('cam').topLimit], 0.3);
		}
	}	
}
function openInfo(){
	scn.stat = 'locked';
	getMesh('cam').view = calcViewSize( scn.v.scroll.camP, getMesh('cam').view);
	getMesh('cam').topLimit = Math.floor(-getMesh('cam').view.y/2);
	let v;
	v = clamp( (Math.ceil(scn.v.scroll.camP)*getMesh('cam').aspect), 40, 80);

	getMesh('infoT', ['infoC']).w = Math.floor(getMesh('cam').view.x * 0.9);
	getMesh('infoT', ['infoC']).position.x = -getMesh('infoT', ['infoC']).w/2;
	getMesh('infoT', ['infoC']).position.y = Math.round(-getMesh('brand').bb.y);
	
	animeItem(getMesh('cam'), 'position', ['x', 'y', 'z'], [0, getMesh('cam').topLimit, v], 0.5);
	animeItem(getMesh('cam'), 'target', ['y'], [getMesh('cam').topLimit], 0.5);	
	animeItem(getMesh('brand'), 'position', ['x', 'y'], [ (-getMesh('cam').view.x/2) + getMesh('brand').bb.x,  -getMesh('brand').bb.y/2 ], 0.5);
	animeItem(getMesh(scn.currIntrsc, ['menu']), 'scale', ['x', 'y', 'z'], [3, 3, 5	], 0.4, 0, function() {
		getMesh('infoT', ['infoC']).visible = true;
		animeItem(getMesh('infoT', ['infoC']), 'position', ['x'], [0], 0.4);
		animeItem(getMesh('infoT', ['infoC']), 'scale', ['x'], [getMesh('infoT', ['infoC']).w], 0.4, 0, function(){
			plotElements( scn.menuInfo[scn.currIntrsc] );
		});
	});
	
	changeColor(scn.currIntrsc, 'active');
	getMesh('menu').activeR = (Math.PI/180 * 360) - getMesh(scn.currIntrsc, ['menu']).data.angle;
	getMesh('menu').activeRDelta = getMesh('menu').activeR;
	if(Math.abs(getMesh('menu').rotation.y - getMesh('menu').activeR) >= Math.PI){
		if(getMesh('menu').rotation.y > getMesh('menu').activeR){
			getMesh('menu').activeRDelta += Math.PI*2;
		}else{
			getMesh('menu').rotation.y += Math.PI*2;
		}
	}
	getMesh('menu').activeRDuration = Math.abs(getMesh('menu').rotation.y - getMesh('menu').activeRDelta)/(Math.PI/180 * 360);
	for(let i = 0; i < getMesh('menu').children.length; i++){
		if(getMesh('menu').children[i].name !== scn.currIntrsc){
			getMesh('menu').children[i].traverse(function(child){
				animeItem(child, 'material', ['opacity'], [0], 0.5);
			});
		}
	}
	animeItem(getMesh('menu'), 'rotation', ['y'], [getMesh('menu').activeRDelta], getMesh('menu').activeRDuration);
	animeItem(getMesh('menu'), 'position', ['y', 'z'], [-getMesh('brand').bb.y/2, -getMesh('menu').r/2], 0.5);
}
function plotElements( content ){
	getMesh('infoBlock', ['infoC']).position.set(0,0,0);
	getMesh('infoBtns').position.set(0,0,0);
	getMesh('infoBlock', ['infoC']).h = 0;
	getMesh('infoBlock', ['infoC']).w = Math.round(getMesh('infoT', ['infoC']).w * 0.9);
	getMesh('infoBlock', ['infoC']).padW = Math.round(getMesh('infoBlock', ['infoC']).w * 0.02);
	getMesh('infoBlock', ['infoC']).padH = Math.round(getMesh('infoBlock', ['infoC']).w * 0.03);
	getMesh('infoBlock', ['infoC']).padMedia = Math.round(getMesh('infoBlock', ['infoC']).padW/4);
	getMesh('infoC').h2.fontSize = Math.round((getMesh('infoBlock', ['infoC']).w/10)/getMesh('cam').aspect);
	getMesh('infoC').p.fontSize = Math.round((getMesh('infoBlock', ['infoC']).w/14)/getMesh('cam').aspect);
	getMesh('infoBlock', ['infoC']).h += getMesh('infoBlock', ['infoC']).padH;
	for( let i = 0; i < content.length; i++){
		let topic = content[i];
		let topicBlock = new Group();
		topicBlock.scale.normalize();
		topicBlock.blockHigher = 0;
		let colsQtd = -1;
		
		if( topic.text ){ colsQtd += topic.text.length };
		if( topic.media ){ colsQtd += topic.media.length };
		colsQtd = getMesh('infoBlock', ['infoC']).padW * colsQtd;
		topicBlock.padQtdW = Math.round(getMesh('infoBlock', ['infoC']).w - colsQtd);
		
		//block text sorted first to reference blockHigher for block media
		if( topic.text ){ 
			setBlockTexts(topicBlock, topic.text); 
		}
		if( topic.media ){ 
			setBlockMedias(topicBlock, topic.media); 
		}
		topicBlock.children.sort((a,b) => a.order - b.order);
		let wPostAccu = 0;
		for( let j = 0; j < topicBlock.children.length; j++){
			if(j === 0 ){
				continue;
			}
			wPostAccu += topicBlock.children[j-1].colW*2;
			topicBlock.children[j].position.x = wPostAccu;
			
		}
		topicBlock.position.y = -(getMesh('infoBlock', ['infoC']).h);
		//get positioned raycastUrlAreaMesh and attach to getMesh('infoBtns')
		topicBlock.traverse( function(child){
			if(child.url){
				getMesh('infoBtns').attach(child);
			}
		});
		getMesh('infoBlock', ['infoC']).h += Math.round(topicBlock.blockHigher + getMesh('infoBlock', ['infoC']).padH);
		getMesh('infoBlock', ['infoC']).attach( topicBlock );
	}
	getMesh('infoBlock', ['infoC']).position.x = -(getMesh('infoBlock', ['infoC']).w/2);
	getMesh('infoBlock', ['infoC']).position.y = getMesh('infoT', ['infoC']).position.y - (getMesh('infoBlock', ['infoC']).padH*2);
	
	
	getMesh('infoBtns').position.x = -(getMesh('infoBlock', ['infoC']).w/2);
	getMesh('infoBtns').position.y = getMesh('infoT', ['infoC']).position.y - getMesh('infoBlock', ['infoC']).padH;
	getMesh('cam').bottomLimit = -Math.floor( getMesh('infoBlock', ['infoC']).h - getMesh('brand').bb.y/2 );
	displayInfo();
}
function setBlockTexts(topicBlock, topicTextsBlocks){
	let block, item;
	for( let j = 0; j < topicTextsBlocks.length; j++){
		block = topicTextsBlocks[j];
		item = new Group();
		item.colW = (block.width * topicBlock.padQtdW)/100;
		item.order = parseInt(block.order);
		item.blockHeight = 0;
		for( let k = 0; k < block.data.length; k++){
			let elmnt = block.data[k];
			let wordsArr = elmnt.info;
			let fontSize = getMesh('infoC')[elmnt.tag].fontSize;
			let fontFamily = getMesh('infoC')[elmnt.tag].fontFamily;
			let textBlock = alignTextBlock(wordsArr, item.colW, fontSize);
			let textMesh = generateText(textBlock, fontFamily, fontSize);
			textMesh.position.y = -item.blockHeight;
			item.blockHeight += textMesh.bb.h/1.6;
			item.attach(textMesh);
		}
		if( topicBlock.blockHigher < item.blockHeight){
			topicBlock.blockHigher = item.blockHeight;
		}
		topicBlock.attach( item );
	}
}
function setBlockMedias(topicBlock, topicMedias){
	let block, item, scalar, posVector, scaleVector, direction, posT;
	for( let j = 0; j < topicMedias.length; j++){
		block = topicMedias[j];
		item = new Group();
		item.colW = ((block.width * topicBlock.padQtdW)/100);
		item.order = parseInt(block.order);
		posVector = 'x';
		scaleVector = 'w';
		direction = 1;
		posT = 0;
		let mediaPad = getMesh('infoBlock', ['infoC']).padMedia;

		if(topicBlock.blockHigher === 0){
			let maxW = 0;
			let maxH = 0;
			for( let k = 0; k < block.data.length; k++){
				maxW += block.data[k].width;
				maxH += block.data[k].height;
			}
			topicBlock.blockHigher = ((item.colW*maxH)/maxW)/block.data.length;
			
		}
		item.colAspect = item.colW/topicBlock.blockHigher;
		if( item.colAspect >= 1){
			scalar = ((topicBlock.blockHigher)/block.data[0].height);

		}
		if( item.colAspect < 1){
			scalar = (item.colW)/block.data[0].width;
			posVector = 'y';
			scaleVector = 'h';
			direction = -1;
		}

		for( let k = 0; k < block.data.length; k++){
			let elmnt = block.data[k];
			let mesh = scn.loaderClasses[elmnt.tag][1](elmnt.src);
			mesh.scale.normalize();
			mesh.scale.setScalar(scalar );
			mesh.position[posVector] = posT;
			posT += (((mesh.bb[scaleVector])*scalar)+mediaPad*2)* direction;
			
			if(elmnt.href != null){
				let rayMesh = genRaycastMesh(mesh.bb.w, mesh.bb.h);
				rayMesh.scale.normalize();
				rayMesh.geometry.translate(mesh.bb.w/2, -mesh.bb.h/2, 0);
				rayMesh.name = elmnt.href;
				rayMesh.url = elmnt.href;				
				rayMesh.scale.setScalar(scalar );
				rayMesh.position.copy( mesh.position );
				mesh.attach(rayMesh);
			}
			item.attach(mesh);
			topicBlock.position.y = -(getMesh('infoBlock', ['infoC']).padH)*2;
			
		}
		
		topicBlock.attach( item );
	}
}
function displayInfo(){
	animeItem(getMesh('infoT', ['infoC']), 'position', ['y'], [ Math.round(-(getMesh('infoBlock', ['infoC']).h/2)) - (getMesh('brand').bb.y)], 0.5);
	animeItem(getMesh('infoT', ['infoC']), 'scale', ['y'], [Math.ceil(getMesh('infoBlock', ['infoC']).h)], 0.5, 0, function(){
		getMesh('infoBlock', ['infoC']).traverse(function(child){
			if(child.isMesh){
				animeItem(child, 'material', ['opacity'], [1], 0.3);
			}
		});
		getMesh('close', ['infoBtns']).position.x = getMesh('cam').view.x;
		getMesh('close', ['infoBtns']).position.y = getMesh('brand').bb.y/2;
		getMesh('close', ['infoBtns']).visible = true;
		animeItem(getMesh('close', ['infoBtns']), 'position', ['x'], [(getMesh('cam').view.x) - (getMesh('brand').bb.x*2) ], 0.3, 0);
		scn.stat = 'scroll';
	});
}
function closeInfo(){
	scn.stat = 'locked';
	getMesh('cam').view = calcViewSize( Math.ceil(getMesh('brand').bb.y*4), getMesh('cam').view);
	getMesh('cam').topLimit = Math.floor(-getMesh('cam').view.y/2);
	getMesh('infoBlock', ['infoC']).traverse(function(child){
		if(child.isMesh){
			animeItem(child, 'material', ['opacity'], [0], 0.5);
		}
	});
	animeItem(getMesh('close', ['infoBtns']), 'position', ['y'], [( (getMesh('cam').position.y) - (getMesh('cam').topLimit) ) + Math.ceil(getMesh('brand').bb.y/2)], 0.5);
	animeItem(getMesh('lightTarget'), 'position', ['y'], [( -4 )], 0.5);
	animeItem(getMesh('cam'), 'position', ['x', 'y', 'z'], [0,  getMesh('cam').topLimit, Math.ceil(getMesh('brand').bb.y*4)], 0.5);
	animeItem(getMesh('cam'), 'target', ['y'], [ getMesh('cam').topLimit ], 0.5, 0, function(){
		animeItem(getMesh('close', ['infoBtns']), 'position', ['x'], [(getMesh('cam').view.x)], 0.5);
		
		animeItem(getMesh('infoT', ['infoC']), 'position', ['y'], [Math.round(-getMesh('brand').bb.y)], 0.4);
		animeItem(getMesh('infoT', ['infoC']), 'scale', ['y'], [0.1], 0.4, 0, function(){
			animeItem(getMesh('infoT', ['infoC']), 'position', ['x'], [-getMesh('infoT', ['infoC']).w/2], 0.4);
			animeItem(getMesh('infoT', ['infoC']), 'scale', ['x'], [0], 0.4, 0, function(){
				getMesh('close', ['infoBtns']).visible = false;
				dispose(getMesh('infoBlock', ['infoC']));
				getMesh('infoBlock', ['infoC']).clear();
				scn.attach(getMesh('close', ['infoBtns']));
				dispose(getMesh('infoBtns'));
				getMesh('infoBtns').clear();
				getMesh('infoBtns').attach(getMesh('close'));
				hideInfo(scn);
			});
		});

	});
}
function hideInfo(){

	for(let i = 0; i < getMesh('menu').children.length; i++){
		if(getMesh('menu').children[i].name != scn.currIntrsc){
			getMesh('menu').children[i].traverse(function(child){
				animeItem(child, 'material', ['opacity'], [1], 0.3);
			})
		}
	}
	animeItem(getMesh('cam'), 'position', ['x', 'y', 'z'], [0,  Math.ceil(-getMesh('brand').bb.y*0.2), Math.ceil(getMesh('brand').bb.y*4)], 0.3);
	animeItem(getMesh('cam'), 'target', ['y'], [ Math.ceil(-getMesh('brand').bb.y*1.2)], 0.3);
	animeItem(getMesh(scn.currIntrsc, ['menu']), 'scale', ['x', 'y', 'z'], [1, 1, 1], 0.3);
	
	animeItem(getMesh('brand'), 'position', ['x', 'y'], [0, Math.ceil(-getMesh('brand').bb.y)], 0.3);
	animeItem(getMesh('menu'), 'position', ['y', 'z'], [ Math.ceil(-getMesh('brand').bb.y)*1.4, 0], 0.3, 0, function(){
		scn.currIntrsc = null;
		scn.stat = 'mov';
	});
}
function pointerClient(e){
	e.preventDefault();
	if ( e.changedTouches ) {
		if ( e.changedTouches.length > 1 ) { return }
			e = e.changedTouches[0];
	}
	scn.pointer.x = ( e.clientX / window.innerWidth ) * 2 - 1;
	scn.pointer.y = - ( e.clientY / window.innerHeight ) * 2 + 1;
	scn.raycaster.setFromCamera( scn.pointer, getMesh('cam') );
}
function pointerdown( e ){
	e.preventDefault();
	pointerClient(e);
	if(scn.stat === 'mov'){
		scn.intersects = scn.raycaster.intersectObjects( getMesh('menu').children, false );
		if ( scn.intersects.length > 0 ) {
			scn.stat = 'locked';
			scn.currIntrsc = scn.intersects[0].object.name;
			//check texture loaded by menuItem existent
			if(!scn.menuInfo[scn.currIntrsc]){
				scn.menuInfo[scn.currIntrsc] = scn.filePaths[scn.currIntrsc];
				delete scn.filePaths[scn.currIntrsc];
				loadFiles( scn.menuInfo[scn.currIntrsc], openInfo );
				return;
			}
			openInfo();
			return;
		}
		if ( scn.intersects.length === 0 ) {
			scn.pointerDown = true;
			scn.initPos = {x: scn.pointer.x, y: scn.pointer.y};
		}
	}
	if(scn.stat === 'scroll'){
		scn.intersects = scn.raycaster.intersectObjects( getMesh('infoBtns').children, false );
		if ( scn.intersects.length > 0 ) {
			if(scn.intersects[0].object.name === "close"){
				scn.stat = 'locked';
				closeInfo();
				return; 
			}
			if(scn.intersects[0].object.name !== "close"){
				linkPage(scn.intersects[0].object.name);
			}
		}
		if ( scn.intersects.length === 0 ) {
			scn.pointerDown = true;
			scn.initPos = {x: scn.pointer.x, y: scn.pointer.y} ;
		}
	}
}
function pointermove( e ) {
	e.preventDefault();
	pointerClient(e);
	if(scn.stat === 'mov'){
		scn.intersects = scn.raycaster.intersectObjects( getMesh('menu').children, false );
		if ( scn.intersects.length > 0 ) {
			if(scn.currIntrsc == null){
				//'new'			
				scn.currIntrsc = scn.intersects[0].object.name;
				changeColor(scn.currIntrsc, "hover" );
				animeItem(getMesh(scn.currIntrsc, ['menu']), 'scale', ['x','y','z'], [1.4, 1.4, 1.4], 0.3);
			}
			if(scn.currIntrsc !== scn.intersects[0].object.name){
				//'changed'
				changeColor(scn.currIntrsc, "normal");
				animeItem(getMesh(scn.currIntrsc, ['menu']), 'scale', ['x','y','z'], [1, 1, 1], 0.3);
				scn.currIntrsc = scn.intersects[0].object.name;
				changeColor(scn.currIntrsc, "hover");
				animeItem(getMesh(scn.currIntrsc, ['menu']), 'scale', ['x','y','z'], [1.4, 1.4, 1.4], 0.3);
			}
		}
		if ( scn.intersects.length === 0 ) {
			if ( scn.currIntrsc !== null ) {
				changeColor(scn.currIntrsc, "normal");
				animeItem(getMesh(scn.currIntrsc, ['menu']), 'scale', ['x','y','z'], [1, 1, 1], 0.3);
				scn.currIntrsc = null;
			}
			if( scn.pointerDown ){
				getMesh('cam').moves.x += (scn.initPos.x - scn.pointer.x);
				getMesh('cam').moves.y += (scn.initPos.y - scn.pointer.y);
			}
		}
	}
	if(scn.stat === 'scroll'){
		if( scn.pointerDown ){
			getMesh('cam').moves.y += (scn.initPos.y - scn.pointer.y)/2;
		}
	}
}
function pointerup( e ){
	e.preventDefault();
	scn.pointerDown = false;
	animeItem(getMesh('cam'), 'moves', ['x'], [0], 0.5);
	animeItem(getMesh('cam'), 'moves', ['y'], [0], 0.5);
	animeItem(getMesh('cam'), 'moves', ['z'], [0], 0.5);
}
function wheel( e ){
	e.preventDefault();
	if(scn.stat === 'mov'){
		let v = e.deltaY/( getMesh('cam').view.x/getMesh('cam').aspect )*2;
		animeItem(getMesh('cam'), 'moves', ['z'], [v], 0.2, 0, function(){
			animeItem(getMesh('cam'), 'moves', ['z'], [0], 0.2);
		});
	}
	if(scn.stat === 'scroll'){
		let v = e.deltaY/( getMesh('cam').view.y/getMesh('cam').aspect )*4;
		animeItem(getMesh('cam'), 'moves', ['y'], [-v], 0.4, 0, function(){
			animeItem(getMesh('cam'), 'moves', ['y'], [0], 0.4);
		});
	}
}
function touchstart( e ){
	e.preventDefault();
	pointerClient(e);
	if(scn.stat === 'mov'){
		scn.intersects = scn.raycaster.intersectObjects( getMesh('menu').children, false );
		if ( scn.intersects.length > 0 ) {
			scn.stat = 'locked';
			scn.currIntrsc = scn.intersects[0].object.name;
			//check texture loaded by menuItem existent
			if(!scn.menuInfo[scn.currIntrsc]){
				scn.menuInfo[scn.currIntrsc] = scn.filePaths[scn.currIntrsc];
				delete scn.filePaths[scn.currIntrsc];
				loadFiles( scn.menuInfo[scn.currIntrsc], openInfo );
				return;
			}
			openInfo();
			return;
		}
		if ( scn.intersects.length === 0 ) {
			scn.pointerDown = true;
			scn.initPos = {x: scn.pointer.x, y: scn.pointer.y};
		}
	}
	if(scn.stat === 'scroll'){
		scn.intersects = scn.raycaster.intersectObjects( getMesh('infoBtns').children, false );
		if ( scn.intersects.length > 0 ) {
			if(scn.intersects[0].object.name === "close"){
				scn.stat = 'locked';
				closeInfo();
				return; 
			}
			if(scn.intersects[0].object.name !== "close"){
				linkPage(scn.intersects[0].object.name);
			}
		}
		if ( scn.intersects.length === 0 ) {
			scn.pointerDown = true;
			scn.initPos = {x: scn.pointer.x, y: scn.pointer.y} ;
		}
	}
}
function touchmove( e ){
	e.preventDefault();
	pointerClient(e);
	if(scn.stat === 'mov'){
		if( scn.pointerDown ){
			getMesh('cam').moves.x += (scn.initPos.x - scn.pointer.x);
			getMesh('cam').moves.y += (scn.initPos.y - scn.pointer.y);
		}
	}
	if(scn.stat === 'scroll'){
		if( scn.pointerDown ){
			getMesh('cam').moves.y += (scn.initPos.y - scn.pointer.y)/2;
		}
	}
}
function touchend( e ){
	e.preventDefault();
	scn.pointerDown = false;
	animeItem(getMesh('cam'), 'moves', ['x'], [0], 0.5);
	animeItem(getMesh('cam'), 'moves', ['y'], [0], 0.5);
	animeItem(getMesh('cam'), 'moves', ['z'], [0], 0.5);
}
function move(){
	getMesh('cam').velocity += (getMesh('cam').speed - getMesh('cam').velocity);
	getMesh('cam').velocity = clamp(getMesh('cam').velocity, 0, getMesh('cam').speed);
	getMesh('cam').translateX(getMesh('cam').velocity * getMesh('cam').moves.x);
	getMesh('cam').translateY(getMesh('cam').velocity * getMesh('cam').moves.y);
	getMesh('cam').translateZ(getMesh('cam').velocity * getMesh('cam').moves.z);
}
function genRaycastMesh(rayW, rayH){
	const rayGeo = new PlaneGeometry( rayW, rayH );
	const rayMat = new MeshBasicMaterial( {color: "#000000", visible: false, depthWrite: false} );
	const rayMesh = new Mesh( rayGeo, rayMat );
	rayGeo.dispose();
	rayMat.dispose();
	return rayMesh;
}
function generateImg(texture){
	texture.colorSpace = SRGBColorSpace;
	let width = texture.source.data.width;
	let height = texture.source.data.height;
	let geometry = new PlaneGeometry( width, height );
	geometry.computeBoundingBox();
	geometry.translate(width/2, -height/2, 0);
	let material = new MeshBasicMaterial( {map: texture, opacity: 0, transparent: true, depthWrite: false, fog: false} );
	let mesh = new Mesh( geometry, material );
	mesh.scale.normalize();
	mesh.bb = {w:width, h:height}
	mesh.aspect = Math.trunc((width/height)*100)/100;
	
	geometry.dispose();
	material.dispose();
	texture.dispose();
	return mesh;
}
function generateVid(data){
	const texture = new VideoTexture( data );
	texture.colorSpace = SRGBColorSpace;
	let width = data.videoWidth;
	let height = data.videoHeight;
	let geometry = new PlaneGeometry( width, height );
	geometry.computeBoundingBox();
	geometry.translate(width/2, -height/2, 0);
	let material = new MeshLambertMaterial( {map: texture, opacity: 0, transparent: true, depthWrite: false, fog: false} );
	let mesh = new Mesh( geometry, material );
	mesh.scale.normalize();
	mesh.bb = {w:width, h:height}
	mesh.aspect = Math.trunc((width/height)*100)/100;
	//mesh.name = "video";
	mesh.vidElement = data;
	mesh.vidElement.play();
	geometry.dispose();
	material.dispose();
	return mesh;
}
function generateSvg(data){
	let width = parseFloat(data.xml.attributes.width.nodeValue);
	let height = parseFloat(data.xml.attributes.height.nodeValue);
	const geo = new PlaneGeometry( width, height );
	geo.computeBoundingBox();
	geo.translate(width/2, -height/2, 0);
	const mat = new MeshBasicMaterial( {color: "#000000", visible: false, side: FrontSide, fog: false} );
	const groupMesh = new Mesh(geo, mat);
	groupMesh.scale.normalize();
	groupMesh.bb = {w:width, h:height};
	groupMesh.aspect = Math.trunc((width/height)*100)/100;
	
	geo.dispose();
	mat.dispose();
	
	let renderOrder = 2;
	for ( const path of data.paths ){
		const fillColor = path.userData.style.fill;
		if ( fillColor !== undefined && fillColor !== 'none' ) {
			const material = new MeshPhongMaterial( {
				color: new Color().setStyle( fillColor ),
				opacity: 0,
				transparent: true,
				depthWrite: false, 
				fog: false,
				side: FrontSide,
				depthWrite: false,
				wireframe: false
			} );
			const shapes = SVGLoader.createShapes( path );
			for ( const shape of shapes ) {
				const geometry = new ShapeGeometry( shape );
				geometry.computeBoundingBox();
				const mesh = new Mesh( geometry, material );
				mesh.scale.y *= -1;
				mesh.renderOrder = renderOrder++;
				groupMesh.add( mesh );
				material.dispose();
				geometry.dispose();
			}
		}
		const strokeColor = path.userData.style.stroke;
		if (strokeColor !== undefined && strokeColor !== 'none' ) {
			const material = new MeshPhongMaterial( {
				color: new Color().setStyle( strokeColor ),
				opacity: 1,
				transparent: true,
				depthWrite: false, 
				fog: false,
				side: FrontSide,
				depthWrite: false,
				wireframe: false
			} );
			for ( const subPath of path.subPaths ) {
				const geometry = SVGLoader.pointsToStroke( subPath.getPoints(), path.userData.style );
				geometry.computeBoundingBox();
				if ( geometry ) {
					const mesh = new Mesh( geometry, material );
					mesh.scale.y *= -1;
					mesh.renderOrder = renderOrder++;
					groupMesh.add( mesh );
					material.dispose();
					geometry.dispose();
				}
			}
		}
	}
	
	return groupMesh;
}
function alignTextBlock(wordsArr, colW, fontSize){
	let wordCueX = 0;
	let textLine = "";
	let fontSizePercent = ((fontSize/2.4)*100)/colW;
	let lineChars = Math.ceil(100/fontSizePercent);
	for (let i = 0; i < wordsArr.length; i++){
		if(i === wordsArr.length-1){
			if( wordCueX + 1 + wordsArr[i].length > lineChars ) {
				textLine += "\n";
			}
			textLine += wordsArr[i];
			return textLine;
		}
		textLine += wordsArr[i];
		wordCueX += (wordsArr[i].length);
		if( wordCueX + 1 >= lineChars || wordCueX + 1 + wordsArr[i+1].length >= lineChars ) {
			textLine += "\n";
			wordCueX = 0;
			continue;
		}
		textLine += " ";
		wordCueX += 1;
	}
}
function generateText(textContent, fontStyle, fontSize){
	let geometry = new TextGeometry( textContent, {
		font: fontStyle,
		size: fontSize,
		height: 0.0,
		depth: 0.0,
		curveSegments: 1,
		bevelEnabled: false,
		bevelThickness: 0,
		bevelSize: 0,
	} );
	let textMat = new MeshBasicMaterial( { color: "#04453A", transparent: true, depthWrite: false, fog: false } );
	let textMesh = new Mesh( geometry, textMat );
	textMesh.scale.normalize();
	textMesh.geometry.computeBoundingBox();
	textMesh.geometry.computeBoundingSphere();
	textMesh.material.opacity = 0;
	
	let width = Math.trunc( Math.abs(textMesh.geometry.boundingBox.min.x - textMesh.geometry.boundingBox.max.x) *100)/100 ;
	let height = Math.trunc( Math.abs(textMesh.geometry.boundingBox.min.y - textMesh.geometry.boundingBox.max.y) *100)/100 ;
	textMesh.geometry.translate(0, 0, 0);
	textMesh.bb = {w:width, h:height};
	geometry.dispose();
	textMat.dispose();
	return textMesh;
}
function setRenderer(){
	let renderer = new WebGLRenderer( { canvas:scn.canvas, antialias: true, alpha: false, precision: "highp" } );
	renderer.setSize( scn.canvas.offsetWidth, scn.canvas.offsetHeight );
	renderer.setPixelRatio( window.devicePixelRatio );
	renderer.shadowMap.enabled = false;
	renderer.toneMapping = ACESFilmicToneMapping;
	renderer.toneMappingExposure = 1;
	return renderer;
}
function setCamera(){
	let cam = new PerspectiveCamera( 50, scn.canvas.offsetWidth/ scn.canvas.offsetHeight, 10, 200  );
	cam.name = 'cam';
	cam.target = new Vector3();
	cam.velocity = 0.0;
	cam.speed = 0.6;
	cam.moves = {x: 0, y:0, z: 0};
	cam.view = new Vector2();
	cam.topLimit = 0;
	cam.attach(setLights());
	return cam;
}
function setLights(){
	let light = new DirectionalLight( 0xFEFEFE, 3 );
	light.name = 'light';
	light.scale.normalize();
	light.position.set( -40, 20, 10 );
	let lightTarget = new Object3D();
	lightTarget.name = 'lightTarget';
	lightTarget.scale.normalize();
	scn.add(lightTarget);
	light.target = lightTarget;
	lightTarget.position.set( 0, -4, -10 );
	return light;
}
function setCarousel(){
	let menu = new Group();
	menu.scale.normalize();
	menu.name = 'menu';
	return menu;
}
function setinfoC(){
	let infoC = new Group();
	infoC.name = 'infoC';
	infoC.position.set(0, 0, 0);
	infoC.h2 = {fontSize: 12, fontFamily: scn.fonts['Rubik-Bold']}
	infoC.p = {fontSize: 6, fontFamily: scn.fonts['Rubik-Regular']}
	
	let infoBlock = new Group();
	infoBlock.name = 'infoBlock';
	infoBlock.scale.normalize();

	infoC.attach( infoBlock );
	
	let infoTGeo = new PlaneGeometry( 1, 1 );
	let infoTMat = new MeshPhongMaterial( { color: 0x33EBCB, flatShading: true ,transparent: false, fog: false } );
	let infoT = new Mesh( infoTGeo, infoTMat );
	infoT.name = 'infoT';
	infoT.scale.normalize();
	infoT.geometry.computeBoundingBox();
	infoT.renderOrder = 0;
	infoT.scale.y = 0.16;
	infoTGeo.dispose();
	infoTMat.dispose();
	
	infoC.attach( infoT );
							
	infoT.visible = false;
	return infoC;
}
function changeColor(ObjName, mode){
	getMesh(ObjName, ['menu']).traverse(function(child){
	 if (child.name !== ObjName){
		animeItem(child.material, 'color', ['r', 'g', 'b'], [ scn.colors[child.name][mode].r, scn.colors[child.name][mode].g, scn.colors[child.name][mode].b], 0.5);
		}
	});
}
function getMesh( name, parents=[] ){
	if(parents.length === 0){
		return scn.children[ scn.children.findIndex(item => item.name === name) ];
	}
	let parent = scn;
	for(let i = 0; i < parents.length; i++){
		parent = parent.children[ parent.children.findIndex(item => item.name === parents[i]) ];
	}
	return parent.children[ parent.children.findIndex(item => item.name === name) ];
}
function clamp(val, min, max) {
    return Math.trunc( (val > max ? max : val < min ? min : val) * 100) / 100;
}
function loadFile(loaderClass, filePath) {
	return new Promise((resolve) => {
		const loader = new loaderClass;
		loader.load(filePath, (data) => {
			resolve(data);
		});
	});
}
function animeItem(item, property, paramArr, endVArr, duration, delay=0, endAction=null, ease=easeInOutQuad){
	duration = Math.trunc(((duration + delay)* 1000)/scn.fps);
	for (let i = 0; i < paramArr.length; i++){
		let startV = item[property][paramArr[i]];
		let deltaV = endVArr[i] - startV;
		if(i > 0){endAction = null}
		scn.renderGroup.push( [ scn.currFrame, duration, item, property, [paramArr[i]], ease, startV, deltaV, endVArr[i], endAction ] );
	}
	return;
}
function animate() {
	scn.now = performance.now();
	if( scn.now - scn.then > scn.fpsD){
		scn.currFrame++;
		render();
		scn.then = performance.now();
	}
	requestAnimationFrame(animate);
}
function render(){
	if(!scn.stat.locked){ move() }
	scn.states[scn.stat]();
	for (let i = 0; i < getMesh('menu').children.length; i++){
		getMesh('menu').children[i].lookAt( getMesh('cam').position );
	}
	for(let i = 0; i < scn.renderGroup.length; i++){
		// [ startFrame, duration(seconds), item, property, param, ease, startV, deltaV, endV, endAction ]
		scn.motionCount = scn.currFrame - scn.renderGroup[i][0];
		if(scn.motionCount >= scn.renderGroup[i][1]){
			scn.renderGroup[i][2][scn.renderGroup[i][3] ][scn.renderGroup[i][4] ] = scn.renderGroup[i][8];
			if(scn.renderGroup[i][9]){
				scn.renderGroup[i][9]();
			}
			scn.renderGroup.splice(i, 1);
			continue;
		}
		scn.renderGroup[i][2][scn.renderGroup[i][3] ][scn.renderGroup[i][4] ] = Math.trunc(scn.renderGroup[i][5](scn.motionCount, scn.renderGroup[i][6], scn.renderGroup[i][7], scn.renderGroup[i][1])*100 )/100;	
	}
	getMesh('cam').lookAt(getMesh('cam').target);	
	scn.renderer.render( scn, getMesh('cam') );
}
function easeInOutQuad(t, b, c, d) {
	if ((t /= d / 2) < 1) return c / 2 * t * t + b;
	return -c / 2 * ((--t) * (t - 2) - 1) + b;
}
function dispose(parentObj){
	parentObj.traverse(function(object){
		if (object.geometry) {
			object.geometry.dispose();
		}
		if (object.material) {
			if (Array.isArray(object.material)) {
				for (const material of object.material) {
					material.dispose();
					// Dispose textures if they exist within the material
					for (const key in material) {
						if (material[key] instanceof Texture) {
							material[key].dispose();
						}
					}
				}
			} else {
				object.material.dispose();
				// Dispose textures if they exist within the material
				for (const key in object.material) {
					if (object.material[key] instanceof Texture) {
						object.material[key].dispose();
					}
				}
			}
		}
	})
}
function linkPage(url){
	window.open(url); 
}
function calcViewSize(depth, target){
	return getMesh('cam').getViewSize(depth, target );
}
function rotateCarousel(obj, cam){
	if(obj.rotation.y >= Math.PI*2){
		obj.rotation.y = obj.rotation.y - Math.PI*2;
	}
	if(obj.rotation.y < 0){
		obj.rotation.y = obj.rotation.y + Math.PI*2;
	}
	obj.rotation.y -= cam.position.x/200 + 0.002;
}

init();
</script>
</body>
</html>
